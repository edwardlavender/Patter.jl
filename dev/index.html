<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Patter.jl · Patter</title><meta name="title" content="Patter.jl · Patter"/><meta property="og:title" content="Patter.jl · Patter"/><meta property="twitter:title" content="Patter.jl · Patter"/><meta name="description" content="Documentation for Patter."/><meta property="og:description" content="Documentation for Patter."/><meta property="twitter:description" content="Documentation for Patter."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Patter</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Patter.jl</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Patter.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Patter.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/edwardlavender/Patter.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/edwardlavender/Patter.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Patter.jl"><a class="docs-heading-anchor" href="#Patter.jl">Patter.jl</a><a id="Patter.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Patter.jl" title="Permalink"></a></h1><ul><li><a href="#Patter.jl">Patter.jl</a></li><li class="no-marker"><ul><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.abs_angle_difference-Tuple{Any, Any}" href="#Patter.abs_angle_difference-Tuple{Any, Any}"><code>Patter.abs_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the smallest absolute rotation between two angles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L124-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.assemble_yobs-Tuple{Vector, Vector{DataType}}" href="#Patter.assemble_yobs-Tuple{Vector, Vector{DataType}}"><code>Patter.assemble_yobs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"># Assemble `yobs` for the particle filter</code></pre><p>Assemble a dictionary of observations (and associated model parameters) for the particle filter. </p><p><strong>Arguments</strong></p><ul><li>datasets: A Vector of DataFrames, one for each data type. Each DataFrame must contain the following columns:<ul><li><code>timestamp</code>: A DateTime Vector of time stamps;</li><li><code>sensor_id</code>: A vector of sensor IDs;</li><li><code>obs</code>: The observation;</li><li>Additional columns required to construct ModelObs instances (that is, model parameters);</li></ul></li><li>model_types: A Vector of ModelObs sub-types for each dataset. </li></ul><p><strong>Details</strong></p><p>The function iterates over datasets and models and creates a typed dictionary of timestamps. Each time step contains a vector of Tuples, with one element for each sensor that recorded an observation at that time stamp. Each element is a tuple that defines the observation and the model parameters (that is, a <code>ModelObs</code> instance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/005-data-assembly.jl#L41-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.cartesian_to_polar-Tuple{Any, Any}" href="#Patter.cartesian_to_polar-Tuple{Any, Any}"><code>Patter.cartesian_to_polar</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Cartesian to polar coordinates</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L117-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.distance" href="#Patter.distance"><code>Patter.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distance(x0::Real, y0::Real, x1::Real, y1::Real)</code></pre><p>Calculate Euclidean distances between coordinates. </p><p><strong>Arguments</strong></p><ul><li><code>x0</code>, <code>y0</code>: The coordinates of the first point;</li><li><code>x1</code>, <code>y1</code>: The coordinates of the second point;</li></ul><p><strong>Returns</strong></p><ul><li>A number that defines the distance between two coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L95-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ext-Tuple{Vector{Real}}" href="#Patter.ext-Tuple{Vector{Real}}"><code>Patter.ext</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Define extent object</p><p>Designed to match GeoArray.bbox() For passing bounding box from R</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}" href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract(map::GeoArrays.GeoArray, x::Real, y::Real)</code></pre><p>Extract the value of a <code>GeoArray</code> (such as a bathymetry grid) at a specififed pair of <code>x</code> and <code>y</code> coordinates.</p><p><strong>Details</strong></p><p>In <code>Patter.jl</code>, <code>NaN</code> elements are taken to define inhospitable habitats, such as land (see <code>is_valid()</code>). </p><p>To extract a value from a map in another format, such as a shapefile, write a custom <code>extract()</code> method.</p><p><strong>Returns</strong></p><ul><li>The value of the <code>GeoArray</code> for a coordinate pair within the bounds of <code>map</code>;</li><li>NaN (of the same type as <code>map</code>&#39;s elements) for a coordinate pair beyond the bounds of <code>map</code>;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.in_bbox-Tuple{Any, Any, Any}" href="#Patter.in_bbox-Tuple{Any, Any, Any}"><code>Patter.in_bbox</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine whether or not a coordinate (x, y) is within a boundary box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.is_valid" href="#Patter.is_valid"><code>Patter.is_valid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_valid(map_value::Real)
is_valid(map_valu::Real, z::Real)</code></pre><p>Determine the validity of a point on a map.</p><p>For 2D (x, y) states, <code>is_valid(map_value)</code> checks if the <code>map_value</code> at point (x, y) is not <code>NaN</code>.</p><p>For 3D (x, y, z) states, <code>is_valid(map_value, z)</code>, checks that <code>map_value</code> at point (x, y) is not <code>NaN</code>, and also ensures that the provided z-coordinate (<code>z</code>) lies within the valid range, specifically 0 &lt; z ≤ <code>map_value</code>.</p><p><strong>Arguments</strong></p><ul><li><code>map_value</code>: The map from which z-coordinates are extracted;</li><li><code>x</code>: The x-coordinate of the point;</li><li><code>y</code>: The y-coordinate of the point;</li><li><code>z</code>: The z-coordinate of the point to be validated (only for the 3D case);</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the conditions for validity are met;</li><li><code>false</code> otherwise;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/001-spatial.jl#L33-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.julia_get" href="#Patter.julia_get"><code>Patter.julia_get</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Julia from R</strong></p><p>A collection of functions that facilitate the translation of inputs from R into Julia.</p><p><strong>Details</strong></p><ul><li><code>Patter.julia_get_xinit()</code> gets a Vector of initial <a href="#Patter.State"><code>State</code></a>s from a DataFrame;</li><li><code>Patter.julia_get_model_types()</code> gets a Vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types from a Vector of Strings;</li><li><code>Patter.julia_get_models()</code> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances from a <code>Vector</code> of <code>DataFrame</code>s that contain parameters and a corresponding vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/010-Julia-from-R.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_move" href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Calculate the logpdf of a restricted movement</strong></p><p>An internal function that calculates the logpdf of a movement from one state to another. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_obs" href="#Patter.logpdf_obs"><code>Patter.logpdf_obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>deep_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/004-model-observation.jl#L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_step-Tuple{StateXY, StateXY, ModelMoveXY, Float64, Float64}" href="#Patter.logpdf_step-Tuple{StateXY, StateXY, ModelMoveXY, Float64, Float64}"><code>Patter.logpdf_step</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Calculate the unnormalised logpdf of an (unrestricted) movement step</strong></p><p><strong>Details</strong></p><ul><li>logpdf<em>step() is wrapped by the internal logpdf</em>move() function</li><li>For new states, a corresponding logpdf_step() method is required</li><li>logpdf_move() accounts for restricted steps, the determinate and the normalisation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L231-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.particle_filter-Tuple{}" href="#Patter.particle_filter-Tuple{}"><code>Patter.particle_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Particle filter</strong></p><p>A particle filtering algorithm that samples from <code>f(X_t | {Y_1 ... Y_t}) for t ∈ 1:Tmax</code>.</p><p><strong>Arguments</strong></p><ul><li><code>timeline</code>: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation.</li><li><code>xinit</code>: A Vector of <a href="#Patter.State"><code>State</code></a> instances that defines the initial state(s) of the animal.</li><li><code>yobs</code>: A Dictionary of observations (see <a href="#Patter.assemble_yobs-Tuple{Vector, Vector{DataType}}"><code>assemble_yobs()</code></a>):         - Dictionary keys should match elements in <code>timeline</code>.        - Each element must be a <code>Vector</code> of <code>Tuple</code>s for that time step (one for each observation/sensor).         - Each <code>Tuple</code> should contain (a) the observation and (b) the model parameters (that is, a <code>ModelObs</code> instance).</li><li><code>move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance.<ul><li>The movement model describes movement from one time step to the next and therefore depends implicitly on the resolution of <code>timeline</code>.</li><li>The movement model should align with the [<code>State</code>] instances in <code>.xinit</code>. For example, a 2-dimensional state (<a href="#Patter.StateXY"><code>StateXY</code></a>) requires a corresponding movement model instance (i.e., <a href="#Patter.ModelMoveXY"><code>ModelMoveXY</code></a>). </li></ul></li><li><code>n_move</code>: An integer that defines the number of attempts used to find a legal move. <ul><li>All <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types contain a <code>map</code> field that defines the region(s) within which movements are allowed.</li><li>Each particle is moved up to <code>n_move</code> times, until a valid movement is simulated. </li><li>Particles that fail to generate a valid move are killed. </li></ul></li><li><code>n_record</code>: An integer that defines the number of particles to record at each time step.<ul><li><code>n_record</code> particles are resampled at each time step and recorded in memory. </li></ul></li><li><code>n_resample</code>: A number that defines the effective sample size for resampling.<ul><li>Particles are resampled when the effective sample size &lt;= <code>n_resample</code>.</li></ul></li><li><code>direction:</code> A <code>String</code> that defines the direction of the filter.<ul><li>&quot;forward&quot; runs the filter forwards in time;</li><li>&quot;backward&quot; runs the filter backwards in time;</li></ul></li></ul><p><strong>Algorithm</strong></p><p><strong>Initiation</strong></p><p>The algorithm is initiated using a <code>Vector</code> of <code>.n_particle</code> <a href="#Patter.State"><code>State</code></a>s (<code>.xinit</code>). </p><p><strong>Movement</strong></p><p>For every time step in the <code>timeline</code>, the internal function <code>Patter.simulate_move()</code> simulates the movement of particles away from previous states into new states using the movement model specified by <code>.model_move</code>. <code>Patter.simulate_move()</code> is an iterative wrapper for a <code>Patter.simulate_step()</code> method that simulates a new <a href="#Patter.State"><code>State</code></a> instance from the previous <a href="#Patter.State"><code>State</code></a>, using the movement model. <code>Patter.simulate_move()</code> implements <code>Patter.simulate_step()</code> iteratively until a legal move is found (or <code>.n_move</code> is reached). Illegal moves are those that land in <code>NaN</code> locations on the <code>map</code> or, in the case of states that include a depth (<code>z</code>) component, are below the depth of the seabed. Particles that fail to generate legal moves are eventually killed by re-sampling (see below).</p><p><strong>Likelihood</strong></p><p>For each valid <a href="#Patter.State"><code>State</code></a> and time stamp in <code>yobs</code>, the log-probability of each observation, given the <a href="#Patter.State"><code>State</code></a>, is evaluated via <code>Patter.logpdf_obs()</code>. The maximum log-probability across all particles is recorded at each time step as an algorithm diagnostic.</p><p><strong>Resampling</strong></p><p>Particles are periodically re-sampled, with replacement, using the low-variance systematic re-sampling algorithm (via <a href="#Patter.resample"><code>resample()</code></a>), when the effective sample size is less than or equal to <code>.n_resample</code>. This has the effect of eliminating impossible particles and duplicating likely ones.</p><p>The algorithm continues in this way, iterating over the <code>timeline</code>, simulating, weighting and (re)sampling particles. At each time step, <code>.n_record</code> particles are saved in memory. If the function fails to converge, a [<code>warning</code>] is returned alongside the outputs up to that time step. Otherwise, the function will continue to the end of the time series.</p><p><strong>Multi-threading</strong></p><p>The iteration over particles (i.e., simulated movements and likelihood evaluations) are multi-threaded. </p><p><strong>Convergence and diagnostics</strong></p><p>Algorithm convergence is not guaranteed. The algorithm may reach a dead-end–-a time step at which there are no valid locations into which the algorithm can step. This may be due to data errors, incorrect assumptions, insufficient sampling effort or poor tuning-parameter settings.</p><p><strong>Returns</strong></p><p>A <code>NamedTuple</code> with the following fields:</p><ul><li><code>timesteps</code>: An <code>Vector{Int64}</code> of time steps;</li><li><code>timestamps</code>: The <code>timeline</code>;</li><li><code>direction</code>: The <code>direction</code>;</li><li><code>state</code>: A <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s:<ul><li>Each row corresponds to a particle; </li><li>Each column corresponds to the <code>timestep</code>;</li></ul></li><li><code>ess</code>: A <code>Vector{Float64}</code> that defines the effective sample size at each time step;</li><li><code>maxlp</code>: A <code>Vector{Float64}</code> that defines the maximum log-posterior at each time step;</li><li><code>convergence</code>: A <code>Bool</code> that defines whether or not the algorithm reached the end of the <code>timeline</code>;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/007-particle-filter.jl#L69-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.r_get_states" href="#Patter.r_get_states"><code>Patter.r_get_states</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>R from Julia</strong></p><p>A collection of functions that facilitate the translation of inputs from <code>Julia</code> into <code>R</code>. </p><p><strong>Details</strong></p><ul><li>[<code>r_get_states</code>] translates a State matrix into a <code>DataFrame</code> that can be passed to <code>R</code>. In the input matrix, each row is a particle and each column is a time step. </li><li>[<code>r_get_dataset</code>] translates a Dictionary of observations into a Vector of DataFrames that can be passed to <code>R</code>.</li></ul><p><strong>Returns</strong></p><p>A long-format <code>DataFrame</code>, with columns for <code>path_id</code>, <code>timestep</code> and each state dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/011-R-from-Julia.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.resample" href="#Patter.resample"><code>Patter.resample</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Systematic resampling algorithm</strong></p><p>Given the weight vector w, resample a set of <em>indices</em> based on low-variance resampling algorithm from Thrun, Burgard, and Fox&#39;s &quot;Probabilistic Robotics&quot;.</p><p><strong>Source</strong></p><p>Code adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.</p><p><strong>Example</strong></p><pre><code class="language-Julia hljs">X = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
w = [0, 0, 0.75, 0.25]

idx = resample(w, 12)
X[idx]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/007-particle-filter.jl#L29-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_move" href="#Patter.simulate_move"><code>Patter.simulate_move</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_move(state::State, model::MoveModel, t::Int64, n_trial::Real)</code></pre><p>Simulate movement from one location (<code>State</code>) into a new location (<code>State</code>).</p><p><strong>Details</strong></p><ul><li><code>simulate_move()</code> is an internal function that uses an <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method to simulate proposals for a new <code>state</code> until a valid proposal is generated;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L194-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_obs" href="#Patter.simulate_obs"><code>Patter.simulate_obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>deep_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/004-model-observation.jl#L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_path_walk-Tuple{}" href="#Patter.simulate_path_walk-Tuple{}"><code>Patter.simulate_path_walk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Simulate movement paths</strong></p><p>This function simulates discrete-time movement path(s) from a vector of initial states and random-walk movement model. </p><p><strong>Arguments</strong></p><ul><li><code>xinit</code>: A Vector of <a href="#Patter.State"><code>State</code></a>s that defines the initial state(s) for the simulation;</li><li><code>move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>nt</code>: An integer that defines the number of time steps;</li></ul><p><strong>Details</strong></p><p>For each initial state, a movement path is simulated. </p><p><strong>Returns</strong></p><p>A matrix:</p><ul><li>Rows: paths</li><li>Columns: time steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/006-data-simulation.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_state_init" href="#Patter.simulate_state_init"><code>Patter.simulate_state_init</code></a> — <span class="docstring-category">Function</span></header><section><div><p>simulate<em>state</em>init(state::State, model::MoveModel, xlim, ylim)</p><p>Simulate an initial state.</p><p>This function is wrapped by the exported function <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a>, which simulates a vector of states.</p><p><strong>Arguments:</strong></p><ul><li><code>state_type</code>: An empty <code>State</code> sub-type, such as <code>StateXY</code>, used for method dispatch only;</li><li><code>model</code>: A <code>MoveModel</code> instance;</li><li><code>xlim</code>, <code>ylim</code>: Pairs of numbers that define the boundaries of the area within which <code>x</code> and <code>y</code> state values are sampled;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L74-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_states_init" href="#Patter.simulate_states_init"><code>Patter.simulate_states_init</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Simulate initial states</strong></p><p>Simulate a vector of initial states for the simulation of movement paths and the particle filter.</p><p><strong>Arguments</strong></p><ul><li><code>state_type</code>: An empty <code>State</code> sub-type, such as <code>StateXY</code>, used for method dispatch only;</li><li><code>move</code>: A <code>MoveModel</code> instance;</li><li><code>n</code>: The number of intial states to simulate;</li><li><code>xlim</code>, <code>ylim</code>: (optional) Pairs of numbers that define the boundaries of the area within which <code>x</code> and <code>y</code> state values are sampled;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_step" href="#Patter.simulate_step"><code>Patter.simulate_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_step(state::State, model::ModelMove, t::Int64)</code></pre><p>Simulate a (tentative) step from one location (<code>State</code>) into a new location (<code>State</code>).</p><p><strong>Details</strong></p><ul><li><code>simulate_step()</code> is a generic function that simulates a new value for the animal&#39;s <code>state</code>;</li><li>Different methods are dispatched according to the <code>state</code> and the movement <code>model</code>;</li><li>New methods must be provided for custom states or movement models;</li><li>Internally, <code>simulate_step()</code> is wrapped by <code>simulate_move()</code>, which implements <code>simulate_step()</code> iteratively until a valid proposal is generated;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L155-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_yobs-Tuple{}" href="#Patter.simulate_yobs-Tuple{}"><code>Patter.simulate_yobs</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Simulate observations</strong></p><p>For each simulated path, simulate a dictionary of observations. </p><p><strong>Arguments</strong></p><ul><li><code>paths</code>: A Matrix of simulated paths; from <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>;</li><li><code>models</code>: A Vector of <code>ModelObs</code> instances;</li><li><code>timeline</code>: A Vector{DateTime} of time stamps;</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary, with one entry for each path;</li><li>Each entry is a dictionary, with one entry for each time stamp;</li><li>Each time stamp entry is a Vector of Tuples, each comprising the observation and the associated <code>ModelObs</code> instance;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/006-data-simulation.jl#L44-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.state_is_valid-Tuple{State, Bool}" href="#Patter.state_is_valid-Tuple{State, Bool}"><code>Patter.state_is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">state_is_valid(state::State, zdim::Bool)</code></pre><p>Determine whether or not a <code>state</code> is valid.</p><p>See also <a href="#Patter.State"><code>State</code></a>, <a href="#Patter.is_valid"><code>is_valid()</code></a>, </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/002-states.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.two_filter_smoother-Tuple{}" href="#Patter.two_filter_smoother-Tuple{}"><code>Patter.two_filter_smoother</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Two filter smoother</p><p>Fearnhead, P., Wyncoll, D., Tawn, J., 2010. A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447–464. https://doi.org/10.1093/biomet/asq013</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/008-particle-smoother.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMove" href="#Patter.ModelMove"><code>Patter.ModelMove</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><code>ModelMove</code> is an abstract type that defines the movement model. </p><p><strong>sub-types</strong></p><ul><li>`<code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (</code>dbn<em>length<code>) and turning angles (</code>dbn</em>angle`);</li><li><code>ModelMoveXY</code>: A sub-type for three-dimensional (x, y, z) random walks, based on distributions for step lengths (<code>dbn_length</code>), turning angles (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li><li><code>ModelMoveXYZD</code>: A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (<code>dbn_length</code>), changes in turning angle (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li></ul><p><strong>Fields</strong></p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. This is required by all movement models;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_angle</code>: The distribution of turning angles;</li><li><code>dbn_angle_delta</code>: The distribution of changes in turning angle;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Details</strong></p><ul><li>ModelMove structures define the parameters of the movement model;</li><li>All ModelMove structures must contain an <code>map</code> field. </li><li>By default, <code>map</code> is assumed to be a GeoArray but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li><li>Users can use a provided structure or write their own;</li><li>For custom ModelMoves, new rstep() methods are required;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMoveXY" href="#Patter.ModelMoveXY"><code>Patter.ModelMoveXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><code>ModelMove</code> is an abstract type that defines the movement model. </p><p><strong>sub-types</strong></p><ul><li>`<code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (</code>dbn<em>length<code>) and turning angles (</code>dbn</em>angle`);</li><li><code>ModelMoveXY</code>: A sub-type for three-dimensional (x, y, z) random walks, based on distributions for step lengths (<code>dbn_length</code>), turning angles (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li><li><code>ModelMoveXYZD</code>: A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (<code>dbn_length</code>), changes in turning angle (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li></ul><p><strong>Fields</strong></p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. This is required by all movement models;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_angle</code>: The distribution of turning angles;</li><li><code>dbn_angle_delta</code>: The distribution of changes in turning angle;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Details</strong></p><ul><li>ModelMove structures define the parameters of the movement model;</li><li>All ModelMove structures must contain an <code>map</code> field. </li><li>By default, <code>map</code> is assumed to be a GeoArray but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li><li>Users can use a provided structure or write their own;</li><li>For custom ModelMoves, new rstep() methods are required;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMoveXYZD" href="#Patter.ModelMoveXYZD"><code>Patter.ModelMoveXYZD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><code>ModelMove</code> is an abstract type that defines the movement model. </p><p><strong>sub-types</strong></p><ul><li>`<code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (</code>dbn<em>length<code>) and turning angles (</code>dbn</em>angle`);</li><li><code>ModelMoveXY</code>: A sub-type for three-dimensional (x, y, z) random walks, based on distributions for step lengths (<code>dbn_length</code>), turning angles (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li><li><code>ModelMoveXYZD</code>: A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (<code>dbn_length</code>), changes in turning angle (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li></ul><p><strong>Fields</strong></p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. This is required by all movement models;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_angle</code>: The distribution of turning angles;</li><li><code>dbn_angle_delta</code>: The distribution of changes in turning angle;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Details</strong></p><ul><li>ModelMove structures define the parameters of the movement model;</li><li>All ModelMove structures must contain an <code>map</code> field. </li><li>By default, <code>map</code> is assumed to be a GeoArray but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li><li>Users can use a provided structure or write their own;</li><li>For custom ModelMoves, new rstep() methods are required;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/003-model-movement.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObs" href="#Patter.ModelObs"><code>Patter.ModelObs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>deep_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/004-model-observation.jl#L9-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObsAcousticLogisTrunc" href="#Patter.ModelObsAcousticLogisTrunc"><code>Patter.ModelObsAcousticLogisTrunc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>deep_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/004-model-observation.jl#L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObsDepthNormalTrunc" href="#Patter.ModelObsDepthNormalTrunc"><code>Patter.ModelObsDepthNormalTrunc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>deep_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/004-model-observation.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObsDepthUniform" href="#Patter.ModelObsDepthUniform"><code>Patter.ModelObsDepthUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>deep_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/004-model-observation.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.State" href="#Patter.State"><code>Patter.State</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a struct that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
  end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new state sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a [<code>Patter.simulate_step()</code>] method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li>Define a [<code>Patter.logpdf_step)</code>] method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a>) to evaluate the probability density of movement from one state to another;</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/002-states.jl#L3-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.StateXY" href="#Patter.StateXY"><code>Patter.StateXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a struct that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
  end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new state sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a [<code>Patter.simulate_step()</code>] method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li>Define a [<code>Patter.logpdf_step)</code>] method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a>) to evaluate the probability density of movement from one state to another;</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/002-states.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.StateXYZ" href="#Patter.StateXYZ"><code>Patter.StateXYZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a struct that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
  end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new state sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a [<code>Patter.simulate_step()</code>] method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li>Define a [<code>Patter.logpdf_step)</code>] method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a>) to evaluate the probability density of movement from one state to another;</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/002-states.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.StateXYZD" href="#Patter.StateXYZD"><code>Patter.StateXYZD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a struct that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
  end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new state sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a [<code>Patter.simulate_step()</code>] method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li>Define a [<code>Patter.logpdf_step)</code>] method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a>) to evaluate the probability density of movement from one state to another;</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/5734cbb0bd7a024e0f43020384849c815aed3984/src/002-states.jl#L88">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Patter.ModelMove"><code>Patter.ModelMove</code></a></li><li><a href="#Patter.ModelMoveXY"><code>Patter.ModelMoveXY</code></a></li><li><a href="#Patter.ModelMoveXYZD"><code>Patter.ModelMoveXYZD</code></a></li><li><a href="#Patter.ModelObs"><code>Patter.ModelObs</code></a></li><li><a href="#Patter.ModelObsAcousticLogisTrunc"><code>Patter.ModelObsAcousticLogisTrunc</code></a></li><li><a href="#Patter.ModelObsDepthNormalTrunc"><code>Patter.ModelObsDepthNormalTrunc</code></a></li><li><a href="#Patter.ModelObsDepthUniform"><code>Patter.ModelObsDepthUniform</code></a></li><li><a href="#Patter.State"><code>Patter.State</code></a></li><li><a href="#Patter.StateXY"><code>Patter.StateXY</code></a></li><li><a href="#Patter.StateXYZ"><code>Patter.StateXYZ</code></a></li><li><a href="#Patter.StateXYZD"><code>Patter.StateXYZD</code></a></li><li><a href="#Patter.abs_angle_difference-Tuple{Any, Any}"><code>Patter.abs_angle_difference</code></a></li><li><a href="#Patter.assemble_yobs-Tuple{Vector, Vector{DataType}}"><code>Patter.assemble_yobs</code></a></li><li><a href="#Patter.cartesian_to_polar-Tuple{Any, Any}"><code>Patter.cartesian_to_polar</code></a></li><li><a href="#Patter.distance"><code>Patter.distance</code></a></li><li><a href="#Patter.ext-Tuple{Vector{Real}}"><code>Patter.ext</code></a></li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract</code></a></li><li><a href="#Patter.in_bbox-Tuple{Any, Any, Any}"><code>Patter.in_bbox</code></a></li><li><a href="#Patter.is_valid"><code>Patter.is_valid</code></a></li><li><a href="#Patter.julia_get"><code>Patter.julia_get</code></a></li><li><a href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a></li><li><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs</code></a></li><li><a href="#Patter.logpdf_step-Tuple{StateXY, StateXY, ModelMoveXY, Float64, Float64}"><code>Patter.logpdf_step</code></a></li><li><a href="#Patter.particle_filter-Tuple{}"><code>Patter.particle_filter</code></a></li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states</code></a></li><li><a href="#Patter.resample"><code>Patter.resample</code></a></li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a></li><li><a href="#Patter.simulate_obs"><code>Patter.simulate_obs</code></a></li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>Patter.simulate_path_walk</code></a></li><li><a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init</code></a></li><li><a href="#Patter.simulate_states_init"><code>Patter.simulate_states_init</code></a></li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step</code></a></li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>Patter.simulate_yobs</code></a></li><li><a href="#Patter.state_is_valid-Tuple{State, Bool}"><code>Patter.state_is_valid</code></a></li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>Patter.two_filter_smoother</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 21 May 2024 09:32">Tuesday 21 May 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
