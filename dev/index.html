<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Patter.jl · Patter</title><meta name="title" content="Patter.jl · Patter"/><meta property="og:title" content="Patter.jl · Patter"/><meta property="twitter:title" content="Patter.jl · Patter"/><meta name="description" content="Documentation for Patter."/><meta property="og:description" content="Documentation for Patter."/><meta property="twitter:description" content="Documentation for Patter."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Patter</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Patter.jl</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Patter.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Patter.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/edwardlavender/Patter.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/edwardlavender/Patter.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Patter.jl"><a class="docs-heading-anchor" href="#Patter.jl">Patter.jl</a><a id="Patter.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Patter.jl" title="Permalink"></a></h1><ul><li><a href="#Patter.jl">Patter.jl</a></li><li class="no-marker"><ul><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.assemble_yobs-Tuple{}" href="#Patter.assemble_yobs-Tuple{}"><code>Patter.assemble_yobs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble_yobs(; datasets::Vector, model_obs_types::Vector{DataType})</code></pre><p>Assemble a dictionary of observations (and associated model parameters) for the particle filter (<a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). </p><p><strong>Arguments (keywords)</strong></p><ul><li><code>datasets</code>: A <code>Vector</code> of <code>DataFrame</code>s, one for each data type. Each <code>DataFrame</code> must contain the following columns:<ul><li><code>timestamp</code>: A <code>DateTime</code> <code>Vector</code> of time stamps;</li><li><code>sensor_id</code>: A <code>Vector</code> of sensor IDs;</li><li><code>obs</code>: A <code>Vector</code> of observations;</li><li>Additional columns required to construct <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances (that is, model parameters);</li></ul></li><li><code>model_obs_types</code>: A <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types (one for each <code>dataset</code>);</li></ul><p><strong>Details</strong></p><p>The function iterates over animal-tracking datasets (for example, acoustic and archival [depth] time series <em>for a particular individual</em>) and corresponding observation model types and creates a typed dictionary of time stamps for the particle filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>&#39;s <code>yobs</code> argument). Each time step contains a <code>Vector</code> of <code>Tuple</code>s, with one element for each sensor that recorded an observation at that time stamp. For example, each element might correspond to an acoustic receiver and/or the individual&#39;s archival tag. Each element is a <code>Tuple</code> that defines the observation and the corresponding observation model parameters (that is, a <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance). </p><p><strong>Returns</strong></p><ul><li>A <code>Dict</code>:<ul><li>Each element corresponds to a <code>timestamp</code>:<ul><li>Each timestamped element contains a <code>Vector</code> of <code>Tuples</code> (one for each observation):<ul><li>Each <code>Tuple</code> contains an observation and the corresponding <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li></ul></li></ul></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a> to assemble real-world datasets for the particle filter;</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> to simulate observations for the particle filter;</li><li><a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to implement the particle filter;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/005-data-assembly.jl#L41-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}" href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract(map::GeoArrays.GeoArray, x::Real, y::Real)</code></pre><p>Extract the value of a <code>GeoArray</code> (such as a bathymetry grid) at a pair of <code>x</code> and <code>y</code> coordinates.</p><p><strong>Details</strong></p><p>In <code>Patter.jl</code>, <code>map</code> is a <code>GeoArray</code> that defines the area within which movements are possible. In our applications, <code>map</code> is often a bathymetry raster that defines the depth of the seabed across the study area. <code>map</code> is an essential field in individual movement models (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>). The internal <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> function supports the simulation of initial states (via <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a>) and the updating of states (via <a href="#Patter.simulate_step"><code>simulate_step()</code></a>), as required to simulate animal movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). Individual states define, at a minimum, the individual&#39;s location (<code>x</code>, <code>y</code>) and the value of the map at that location (<code>map_value</code>), which is extracted by <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> (see <a href="#Patter.State"><code>State</code></a>). The Coordinate Reference Systems for <code>map</code>, <code>x</code> and <code>y</code> must align for this to work (i.e., <code>map</code> should use a Universal Transverse Mercator projection with coordinates in metres). <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> is exported so that it can be used in new methods (for custom states or movement models) of these functions. The simulation of individual movements (via <a href="#Patter.simulate_step"><code>simulate_step()</code></a>) is implemented iteratively (via <a href="#Patter.simulate_move"><code>simulate_move()</code></a>) until a valid movement is found. <code>NaN</code> is taken to define inhospitable habitats, such as land, into which the individual cannot move (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). It should be possible to use a <code>map</code> in another format (such as a shapefile) within these routines, with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method that returns <code>NaN</code> in inhospitable habitats and a numeric constant otherwise. </p><p><strong>Returns</strong></p><ul><li>The value of the <code>GeoArray</code> for a coordinate pair within the bounds of <code>map</code>;</li><li>NaN (of the same type as <code>map</code>&#39;s elements) for a coordinate pair beyond the bounds of <code>map</code>;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> for <a href="#Patter.State"><code>State</code></a> sub-types;</li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract</code></a> to extract values from <code>map</code> at <a href="#Patter.State"><code>State</code></a> coordinates;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/001-spatial.jl#L5-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.is_valid" href="#Patter.is_valid"><code>Patter.is_valid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_valid(map_value::Real)
is_valid(map_value::Real, z::Real)</code></pre><p>Determine the validity of a point on a <code>map</code>.</p><p>For two-dimensional (x, y) states, <code>is_valid(map_value)</code> checks if the <code>map_value</code> (at a point (<code>x</code>, <code>y</code>)) is not <code>NaN</code>.</p><p>For states with a depth (<code>z</code>) component, <code>is_valid(map_value, z)</code>, checks that <code>map_value</code> is not <code>NaN</code> and that the provided z-coordinate (<code>z</code>) lies within the valid range, specifically <code>0 &lt; z ≤ map_value</code> (i.e., the animal is not below the seabed).</p><p><strong>Arguments</strong></p><ul><li><code>map_value</code>: The value of the <code>map</code> in a particular location;</li><li><code>z</code>: (optional) The z-coordinate (depth) of the animal, used for states that contain a depth component only;</li></ul><p><strong>Details</strong></p><p>These are internal functions. They are used to validate simulated individual states (see <a href="#Patter.State"><code>State</code></a>). Individual states (i.e., locations) are simulated via <a href="#Patter.simulate_step"><code>simulate_step()</code></a>. <a href="#Patter.simulate_move"><code>simulate_move()</code></a> wraps <a href="#Patter.simulate_step"><code>simulate_step()</code></a>, iteratively proposing states until a valid state is found. This is required to simulate animal movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li><code>true</code> if the conditions for validity are met;</li><li><code>false</code> otherwise;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> for <a href="#Patter.State"><code>State</code></a> sub-types;</li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract</code></a> to extract values from <code>map</code> at <a href="#Patter.State"><code>State</code></a> coordinates;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/001-spatial.jl#L41-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.julia_get" href="#Patter.julia_get"><code>Patter.julia_get</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>Julia</code> from <code>R</code></strong></p><p>A collection of internal functions that facilitate the translation of objects from <code>R</code> into <code>Julia</code> objects.</p><p><strong>Details</strong></p><ul><li><a href="#Patter.julia_get_xinit"><code>Patter.julia_get_xinit()</code></a> gets a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s from a <code>DataFrame</code>;</li><li><a href="#Patter.julia_get_model_obs_types"><code>Patter.julia_get_model_obs_types()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types from a Vector of <code>String</code>s;</li><li><a href="#Patter.julia_get_model_obs"><code>Patter.julia_get_model_obs()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances from a <code>Vector</code> of <code>DataFrame</code>s that contain parameters and a corresponding vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/010-Julia-from-R.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.julia_get_model_obs" href="#Patter.julia_get_model_obs"><code>Patter.julia_get_model_obs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>Julia</code> from <code>R</code></strong></p><p>A collection of internal functions that facilitate the translation of objects from <code>R</code> into <code>Julia</code> objects.</p><p><strong>Details</strong></p><ul><li><a href="#Patter.julia_get_xinit"><code>Patter.julia_get_xinit()</code></a> gets a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s from a <code>DataFrame</code>;</li><li><a href="#Patter.julia_get_model_obs_types"><code>Patter.julia_get_model_obs_types()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types from a Vector of <code>String</code>s;</li><li><a href="#Patter.julia_get_model_obs"><code>Patter.julia_get_model_obs()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances from a <code>Vector</code> of <code>DataFrame</code>s that contain parameters and a corresponding vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/010-Julia-from-R.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.julia_get_model_obs_types" href="#Patter.julia_get_model_obs_types"><code>Patter.julia_get_model_obs_types</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>Julia</code> from <code>R</code></strong></p><p>A collection of internal functions that facilitate the translation of objects from <code>R</code> into <code>Julia</code> objects.</p><p><strong>Details</strong></p><ul><li><a href="#Patter.julia_get_xinit"><code>Patter.julia_get_xinit()</code></a> gets a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s from a <code>DataFrame</code>;</li><li><a href="#Patter.julia_get_model_obs_types"><code>Patter.julia_get_model_obs_types()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types from a Vector of <code>String</code>s;</li><li><a href="#Patter.julia_get_model_obs"><code>Patter.julia_get_model_obs()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances from a <code>Vector</code> of <code>DataFrame</code>s that contain parameters and a corresponding vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/010-Julia-from-R.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.julia_get_xinit" href="#Patter.julia_get_xinit"><code>Patter.julia_get_xinit</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>Julia</code> from <code>R</code></strong></p><p>A collection of internal functions that facilitate the translation of objects from <code>R</code> into <code>Julia</code> objects.</p><p><strong>Details</strong></p><ul><li><a href="#Patter.julia_get_xinit"><code>Patter.julia_get_xinit()</code></a> gets a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s from a <code>DataFrame</code>;</li><li><a href="#Patter.julia_get_model_obs_types"><code>Patter.julia_get_model_obs_types()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types from a Vector of <code>String</code>s;</li><li><a href="#Patter.julia_get_model_obs"><code>Patter.julia_get_model_obs()</code></a> gets a <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances from a <code>Vector</code> of <code>DataFrame</code>s that contain parameters and a corresponding vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/010-Julia-from-R.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_move" href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logpdf_move(state_from::State, state_to::State, state_zdim::Bool, 
            model_move::ModelMove, t::Int, box, 
            n_sim::Int,
            cache::LRU)</code></pre><p>Evaluate the log probability of a movement step between two <a href="#Patter.State"><code>State</code></a>s (<code>state_from</code> and <code>state_to</code>). </p><p><strong>Arguments</strong></p><ul><li><code>state_from</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> from which the animal moved;</li><li><code>state_to</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> into which the animal moved;</li><li><code>state_zdim</code>: A <code>Boolian</code> that defines whether or not <code>state_from</code> and <code>state_to</code> contain a <code>z</code> (depth) dimension;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>box</code>: (optional) A <code>NamedTuple</code> (<code>min_x</code>, <code>max_x</code>, <code>min_y</code>, <code>max_y</code>) that defines a &#39;mobility box&#39; within which movements between <code>state_from</code> and <code>state_to</code> are always (theoretically) legal. This can be provided if <code>state_from</code> and <code>state_to</code> are <a href="#Patter.StateXY"><code>StateXY</code></a> instances and <code>model_move.map</code> does not contain <code>NA</code>s;</li><li><code>n_sim</code>: An integer that defines the number of Monte Carlo simulations (used to approximate the normalisation constant);</li><li><code>cache</code>: A Least Recently Used (LRU) Cache;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> is an internal function that evaluates the log probability of a movement step between two <a href="#Patter.State"><code>State</code></a>(s) (i.e., locations). This function wraps <a href="#Patter.logpdf_step"><code>logpdf_step()</code></a>, accounting for accounting for restrictions to movement; that is, <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> evaluates <code>logpdf_step(state_from, state_to, model_move, length, angle) + log(abs(determinate)) - log(Z)</code> where <code>Z</code> is the normalisation constant. If <code>state_from</code> and <code>state_to</code> are two-dimensional states (i.e., <a href="#Patter.StateXY"><code>StateXY</code></a> instances) and <code>model_move.map</code> does not contain <code>NaN</code>s, a &#39;mobility <code>box</code>&#39; can be provided. This is a <code>NamedTuple</code> of coordinates that define the region within which movements between two locations are always theoretically legal. In this instance, the normalisation constant is simply <code>log(1.0)</code>. Otherwise, a Monte Carlo simulation of <code>n_sim</code> iterations is required to approximate the normalisation constant, accounting for invalid movements, which is more expensive (see <a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>logpdf_move_normalisation()</code></a>). <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> is used for particle smoothing (see <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A number (log probability); </li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> and <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> to evaluate the log-probability of movement between two locations;</li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>logpdf_move_normalisation()</code></a> for estimation of the normalisation constant;</li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a> for the front-end function that uses these routines for particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L373-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}" href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>Patter.logpdf_move_normalisation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logpdf_move_normalisation(state::State, state_zdim::Bool, 
                          model_move::ModelMove, t::Int, n_sim::Int, 
                          cache::LRU)</code></pre><p>Approximate the normalisation constant for the (log) probability density of movement from one <a href="#Patter.State"><code>State</code></a> (location) into another. </p><p><strong>Arguments</strong></p><ul><li><code>state_from</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> from which the animal moved;</li><li><code>state_zdim</code>: A <code>Boolian</code> that defines whether or not <code>state_from</code> contains a <code>z</code> (depth) dimension;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>n_sim</code>: An integer that defines the number of Monte Carlo simulations;</li><li><code>cache</code>: A Least Recently Used (LRU) cache;</li></ul><p><strong>Details</strong></p><p>This internal function runs a Monte Carlo simulation of <code>n_sim</code> iterations to estimate the normalisation constant for the (log) probability of movement from one <a href="#Patter.State"><code>State</code></a> (<code>state_from</code>) into another. A Beta(1, 1) prior is used to correct for simulations that fail to generate valid move from <code>state_from</code>. The normalisation constant for a given <a href="#Patter.State"><code>State</code></a> is stored in a LRU cache. This function is used by <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> to evaluate the (log) probability of movement between two states, which is required for particle smoothing (see <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A number (the normalisation constant); </li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> and <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> to evaluate the log-probability of movement between two locations;</li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>logpdf_move_normalisation()</code></a> for estimation of the normalisation constant;</li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a> for the front-end function that uses these routines for particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L452-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_obs" href="#Patter.logpdf_obs"><code>Patter.logpdf_obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/004-model-observation.jl#L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_step" href="#Patter.logpdf_step"><code>Patter.logpdf_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logpdf_step(state_from::State, state_to::State, model_move::ModelMove, length, angle)</code></pre><p>Evaluate the (unnormalised) log probability of an (unrestricted) movement step. </p><p><strong>Arguments</strong></p><ul><li><code>state_from</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> from which the animal moved;</li><li><code>state_to</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> into which the animal moved;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>length</code>: A float that defines the step length (i.e., the Euclidean distance between <code>state_from</code> (<code>x</code>, <code>y</code>) and <code>state_to</code> (<code>x</code>, <code>y</code>));</li><li><code>angle</code>: A float that defines the angle (in polar coordinates) between <code>state_from</code> (<code>x</code>, <code>y</code>) and <code>state_to</code> (<code>x</code>, <code>y</code>);</li></ul><p><strong>Details</strong></p><p><a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> is an internal generic function that evaluates the (unnormalised) log probability of an (unrestricted) movement step between two <a href="#Patter.State"><code>State</code></a>(s) (i.e., locations). Methods are provided for the built-in <a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types, but need to be provided for custom sub-types. Internally, <a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> is wrapped by <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a>, which evaluates the log probability of movement between two <a href="#Patter.State"><code>State</code></a>s, accounting for restrictions to movement; that is, <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> evaluates <code>logpdf_step(state_from, state_to, model_move, length, angle) + log(abs(determinate)) - log(Z)</code> where <code>Z</code> is the normalisation constant. This is required for particle smoothing (see <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A number (log probability); </li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> and <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> to evaluate the log-probability of movement between two locations;</li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>logpdf_move_normalisation()</code></a> for estimation of the normalisation constant;</li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a> for the front-end function that uses these routines for particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L325-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.particle_filter-Tuple{}" href="#Patter.particle_filter-Tuple{}"><code>Patter.particle_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Particle filter</strong></p><p>A particle filtering algorithm that samples from <code>f(X_t | {Y_1 ... Y_t}) for t ∈ 1:t</code>.</p><p><strong>Arguments (keywords)</strong></p><ul><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li><li><code>xinit</code>: A <code>Vector</code> of <a href="#Patter.State"><code>State</code></a> instances that defines the initial state(s) of the animal;</li><li><code>yobs</code>: A Dictionary of observations:<ul><li>Dictionary keys should match elements in <code>timeline</code>;</li><li>Each element must be a <code>Vector</code> of <code>Tuple</code>s for that time step (one for each observation/sensor);</li><li>Each <code>Tuple</code> should contain (a) the observation and (b) the model parameters (that is, a <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance);</li></ul></li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance:<ul><li>The movement model describes movement from one time step to the next and therefore depends implicitly on the resolution of <code>timeline</code>;</li><li>The movement model should align with the <a href="#Patter.State"><code>State</code></a> instances in <code>xinit</code>. For example, a two-dimensional state (<a href="#Patter.StateXY"><code>StateXY</code></a>) requires a corresponding movement model instance (i.e., <a href="#Patter.ModelMoveXY"><code>ModelMoveXY</code></a>); </li></ul></li><li><code>n_move</code>: An integer that defines the number of attempts used to find a legal move; <ul><li>All <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types contain a <code>map</code> field that defines the region(s) within which movements are allowed (see <a href="#Patter.is_valid"><code>is_valid()</code></a>);</li><li>Each particle is moved up to <code>n_move</code> times, until a valid movement is simulated;</li><li>Particles that fail to generate a valid move are killed;</li></ul></li><li><code>n_record</code>: An integer that defines the number of particles to record at each time step:<ul><li><code>n_record</code> particles are resampled at each time step and recorded in memory;</li></ul></li><li><code>n_resample</code>: A number that defines the effective sample size for resampling:<ul><li>Particles are resampled when the effective sample size &lt;= <code>n_resample</code>;</li></ul></li><li><code>direction:</code> A <code>String</code> that defines the direction of the filter:<ul><li><code>&quot;forward&quot;</code> runs the filter forwards in time;</li><li><code>&quot;backward&quot;</code> runs the filter backwards in time;</li></ul></li></ul><p><strong>Algorithm</strong></p><p><strong>Initiation</strong></p><p>The algorithm is initiated using a <code>Vector</code> of <code>n_particle</code> <a href="#Patter.State"><code>State</code></a>s (<code>xinit</code>). See <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states for the filter.  </p><p><strong>Movement</strong></p><p>For every time step in the <code>timeline</code>, the internal function <a href="#Patter.simulate_move"><code>simulate_move()</code></a> simulates the movement of particles away from previous <a href="#Patter.State"><code>State</code></a>s into new <a href="#Patter.State"><code>State</code></a>s using the movement model, as specified by <code>model_move</code>. <a href="#Patter.simulate_move"><code>simulate_move()</code></a> is an iterative wrapper for a <a href="#Patter.simulate_step"><code>simulate_step()</code></a> method that simulates a new <a href="#Patter.State"><code>State</code></a> instance from the previous <a href="#Patter.State"><code>State</code></a>. <a href="#Patter.simulate_move"><code>simulate_move()</code></a> implements <a href="#Patter.simulate_step"><code>simulate_step()</code></a> iteratively until a legal move is found (or <code>n_move</code> is reached). For custom <a href="#Patter.State"><code>State</code></a> or <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types, a corresponding <a href="#Patter.simulate_step"><code>simulate_step()</code></a> method is required. Illegal moves are those that land in <code>NaN</code> locations on the <code>map</code> or, in the case of <a href="#Patter.State"><code>State</code></a>s that include a depth (<code>z</code>) component, are below the depth of the seabed (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). Particles that fail to generate legal moves are eventually killed by re-sampling (see below).</p><p><strong>Likelihood</strong></p><p>Observations are used to weight simulated particles. To simulate observations for filtering, use <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a>. To assemble real-world observations for filtering, see <a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a>. For each valid <a href="#Patter.State"><code>State</code></a> and time stamp in <code>yobs</code>, the log-probability of each observation, given the <a href="#Patter.State"><code>State</code></a>, is evaluated via <a href="#Patter.logpdf_obs"><code>logpdf_obs()</code></a>. For custom <a href="#Patter.State"><code>State</code></a> or <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types, a corresponding <a href="#Patter.logpdf_obs"><code>logpdf_obs()</code></a> method is required. The maximum weight across all particles (<code>maxlp</code>) is recorded at each time step as an algorithm diagnostic. (This metric can be intepreted as the maximum log-posterior if resampling is implemented at every time step.)</p><p><strong>Resampling</strong></p><p>Particles are periodically re-sampled, with replacement, using the low-variance systematic re-sampling algorithm (via <a href="#Patter.resample"><code>resample()</code></a>), when the effective sample size is less than or equal to <code>n_resample</code>. This has the effect of eliminating impossible particles and duplicating likely ones.</p><p>The algorithm continues in this way, iterating over the <code>timeline</code>, simulating, weighting and (re)sampling particles. At each time step, <code>n_record</code> particles are saved in memory. If the function fails to converge, a warning is returned alongside the outputs up to that time step. Otherwise, the function will continue to the end of the time series.</p><p><strong>Multi-threading</strong></p><p>The iteration over particles (i.e., simulated movements and likelihood evaluations) are multi-threaded. </p><p><strong>Convergence and diagnostics</strong></p><p>Algorithm convergence is not guaranteed. The algorithm may reach a dead-end–-a time step at which there are no valid locations into which the algorithm can step. This may be due to data errors, incorrect assumptions, insufficient sampling effort or poor tuning-parameter settings.</p><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> with the following fields:<ul><li><code>timesteps</code>: An <code>Vector{Int64}</code> of time steps;</li><li><code>timestamps</code>: The <code>timeline</code>;</li><li><code>direction</code>: The <code>direction</code>;</li><li><code>state</code>: A <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s:<ul><li>Each row corresponds to a particle; </li><li>Each column corresponds to the <code>timestep</code>;</li></ul></li><li><code>ess</code>: A <code>Vector{Float64}</code> that defines the effective sample size at each time step;</li><li><code>maxlp</code>: A <code>Vector{Float64}</code> that defines the maximum log weight at each time step (i.e., the maximum log-posterior, if resampling is implemented at every time step);</li><li><code>convergence</code>: A <code>Boolian</code> that defines whether or not the algorithm reached the end of the <code>timeline</code>;</li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a>, <a href="#Patter.ModelMove"><code>ModelMove</code></a> and <a href="#Patter.ModelObs"><code>ModelObs</code></a> for <a href="#Patter.State"><code>State</code></a>, movement model and observation model sub-types;</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> and <a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a> to prepare observations for the particle filter;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>simulate_move()</code></a> for the internal routines used to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_obs"><code>logpdf_obs()</code></a> methods to evaluate the log probability of observations;</li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a> to implement particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/007-particle-filter.jl#L83-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.r_get" href="#Patter.r_get"><code>Patter.r_get</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>R</code> from <code>Julia</code></strong></p><p>A collection of internal functions that facilitate the translation of <code>Julia</code> objects into <code>R</code>. </p><p><strong>Details</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> translates a Dictionary of observations into a <code>Vector</code> of <code>DataFrame</code>s that can be passed to <code>R</code>.</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> translates a <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s into a <code>DataFrame</code> that can be passed to <code>R</code>. In the input <code>Matrix</code>, each row is a particle and each column is a time step. </li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> wraps <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> and translates particle outputs (from <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> and <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>) into a <code>NamedTuple</code> for <code>R</code>.</li></ul><p>These functions are <a href="#Patter.State"><code>State</code></a> and model agnostic; that is, they work irrespective of the input <a href="#Patter.State"><code>State</code></a> and model sub-types. Custom methods are not required to handle novel sub-types. </p><p><strong>Returns</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> returns a <code>Vector</code> of <code>DataFrame</code>s, with columns for <code>timestamp</code>, <code>obs</code> and the observation model parameters;</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> returns a long-format <code>DataFrame</code>, with columns for <code>path_id</code>, <code>timestep</code> and each state dimension;</li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> returns a <code>NamedTuple</code> of particle information, including:<ul><li><code>states</code>: A <code>DataFrame</code> of <a href="#Patter.State"><code>State</code></a> dimensions (from <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a>);</li><li><code>diagnostics</code>: A <code>DataFrame</code> of algorithm diagnostics, including <code>timestep</code>, <code>timestamp</code>, <code>ess</code> and <code>maxlp</code> columns;</li><li><code>convergence</code>: A <code>Boolian</code> that defines algorithm convergence;</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/011-R-from-Julia.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.r_get_dataset" href="#Patter.r_get_dataset"><code>Patter.r_get_dataset</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>R</code> from <code>Julia</code></strong></p><p>A collection of internal functions that facilitate the translation of <code>Julia</code> objects into <code>R</code>. </p><p><strong>Details</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> translates a Dictionary of observations into a <code>Vector</code> of <code>DataFrame</code>s that can be passed to <code>R</code>.</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> translates a <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s into a <code>DataFrame</code> that can be passed to <code>R</code>. In the input <code>Matrix</code>, each row is a particle and each column is a time step. </li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> wraps <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> and translates particle outputs (from <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> and <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>) into a <code>NamedTuple</code> for <code>R</code>.</li></ul><p>These functions are <a href="#Patter.State"><code>State</code></a> and model agnostic; that is, they work irrespective of the input <a href="#Patter.State"><code>State</code></a> and model sub-types. Custom methods are not required to handle novel sub-types. </p><p><strong>Returns</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> returns a <code>Vector</code> of <code>DataFrame</code>s, with columns for <code>timestamp</code>, <code>obs</code> and the observation model parameters;</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> returns a long-format <code>DataFrame</code>, with columns for <code>path_id</code>, <code>timestep</code> and each state dimension;</li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> returns a <code>NamedTuple</code> of particle information, including:<ul><li><code>states</code>: A <code>DataFrame</code> of <a href="#Patter.State"><code>State</code></a> dimensions (from <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a>);</li><li><code>diagnostics</code>: A <code>DataFrame</code> of algorithm diagnostics, including <code>timestep</code>, <code>timestamp</code>, <code>ess</code> and <code>maxlp</code> columns;</li><li><code>convergence</code>: A <code>Boolian</code> that defines algorithm convergence;</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/011-R-from-Julia.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.r_get_particles" href="#Patter.r_get_particles"><code>Patter.r_get_particles</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>R</code> from <code>Julia</code></strong></p><p>A collection of internal functions that facilitate the translation of <code>Julia</code> objects into <code>R</code>. </p><p><strong>Details</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> translates a Dictionary of observations into a <code>Vector</code> of <code>DataFrame</code>s that can be passed to <code>R</code>.</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> translates a <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s into a <code>DataFrame</code> that can be passed to <code>R</code>. In the input <code>Matrix</code>, each row is a particle and each column is a time step. </li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> wraps <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> and translates particle outputs (from <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> and <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>) into a <code>NamedTuple</code> for <code>R</code>.</li></ul><p>These functions are <a href="#Patter.State"><code>State</code></a> and model agnostic; that is, they work irrespective of the input <a href="#Patter.State"><code>State</code></a> and model sub-types. Custom methods are not required to handle novel sub-types. </p><p><strong>Returns</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> returns a <code>Vector</code> of <code>DataFrame</code>s, with columns for <code>timestamp</code>, <code>obs</code> and the observation model parameters;</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> returns a long-format <code>DataFrame</code>, with columns for <code>path_id</code>, <code>timestep</code> and each state dimension;</li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> returns a <code>NamedTuple</code> of particle information, including:<ul><li><code>states</code>: A <code>DataFrame</code> of <a href="#Patter.State"><code>State</code></a> dimensions (from <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a>);</li><li><code>diagnostics</code>: A <code>DataFrame</code> of algorithm diagnostics, including <code>timestep</code>, <code>timestamp</code>, <code>ess</code> and <code>maxlp</code> columns;</li><li><code>convergence</code>: A <code>Boolian</code> that defines algorithm convergence;</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/011-R-from-Julia.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.r_get_states" href="#Patter.r_get_states"><code>Patter.r_get_states</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>R</code> from <code>Julia</code></strong></p><p>A collection of internal functions that facilitate the translation of <code>Julia</code> objects into <code>R</code>. </p><p><strong>Details</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> translates a Dictionary of observations into a <code>Vector</code> of <code>DataFrame</code>s that can be passed to <code>R</code>.</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> translates a <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s into a <code>DataFrame</code> that can be passed to <code>R</code>. In the input <code>Matrix</code>, each row is a particle and each column is a time step. </li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> wraps <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> and translates particle outputs (from <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> and <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>) into a <code>NamedTuple</code> for <code>R</code>.</li></ul><p>These functions are <a href="#Patter.State"><code>State</code></a> and model agnostic; that is, they work irrespective of the input <a href="#Patter.State"><code>State</code></a> and model sub-types. Custom methods are not required to handle novel sub-types. </p><p><strong>Returns</strong></p><ul><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset()</code></a> returns a <code>Vector</code> of <code>DataFrame</code>s, with columns for <code>timestamp</code>, <code>obs</code> and the observation model parameters;</li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> returns a long-format <code>DataFrame</code>, with columns for <code>path_id</code>, <code>timestep</code> and each state dimension;</li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles()</code></a> returns a <code>NamedTuple</code> of particle information, including:<ul><li><code>states</code>: A <code>DataFrame</code> of <a href="#Patter.State"><code>State</code></a> dimensions (from <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a>);</li><li><code>diagnostics</code>: A <code>DataFrame</code> of algorithm diagnostics, including <code>timestep</code>, <code>timestamp</code>, <code>ess</code> and <code>maxlp</code> columns;</li><li><code>convergence</code>: A <code>Boolian</code> that defines algorithm convergence;</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/011-R-from-Julia.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.resample" href="#Patter.resample"><code>Patter.resample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resample(w::Vector{Float64}, n::Int)</code></pre><p>Given a weight vector <code>w</code>, resample a set of <em>indices</em> based on low-variance resampling algorithm from Thrun, Burgard and Fox&#39;s &quot;Probabilistic Robotics&quot;.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: A <code>Vector{Float64}</code> of weights;</li><li><code>n</code>: An integer that defines the number of particles;</li></ul><p><strong>Details</strong></p><p>This is an internal function that implements systematic resampling in the particle filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>) and smoothing algorithms (see <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>). Note that for large <code>n</code>, the function is not numerically stable. </p><p><strong>Returns</strong></p><ul><li>An integer vector of indices;</li></ul><p><strong>Example</strong></p><pre><code class="language-Julia hljs">X = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
w = [0, 0, 0.75, 0.25]

idx = resample(w, 12)
X[idx]</code></pre><p><strong>Source</strong></p><p>Code adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/007-particle-filter.jl#L29-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_move" href="#Patter.simulate_move"><code>Patter.simulate_move</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_move(state::State, model_move::ModelMove, t::Int64, n_trial::Real)</code></pre><p>Simulate movement from one location (<a href="#Patter.State"><code>State</code></a>) into a new location (<a href="#Patter.State"><code>State</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines the animal&#39;s previous <a href="#Patter.State"><code>State</code></a>;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>n_trial</code>: A number that defines the number of attempts to simulate a valid <a href="#Patter.State"><code>State</code></a>;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.simulate_move"><code>simulate_move()</code></a> is an internal function that uses a <a href="#Patter.simulate_step"><code>simulate_step()</code></a> method to simulate new state proposals iteratively until a valid <a href="#Patter.State"><code>State</code></a> is generated or <code>n_trial</code> is reached (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). For custom <a href="#Patter.State"><code>State</code></a>s or <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types, corresponding <a href="#Patter.simulate_step"><code>simulate_step()</code></a> methods must be provided for this function. <a href="#Patter.simulate_move"><code>simulate_move()</code></a> is used to simulate movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A <code>Tuple</code> that comprises the simulated <a href="#Patter.State"><code>State</code></a> instance and the (log) weight; i.e., <ul><li><code>([State], 0.0)</code> if <a href="#Patter.State"><code>State</code></a> is valid;</li><li><code>([State], -Inf)</code> if <a href="#Patter.State"><code>State</code></a> is invalid;</li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L266-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_obs" href="#Patter.simulate_obs"><code>Patter.simulate_obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/004-model-observation.jl#L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_path_walk-Tuple{}" href="#Patter.simulate_path_walk-Tuple{}"><code>Patter.simulate_path_walk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_path_walk(; xinit = Vector, model_move::ModelMove, timeline::Vector{DateTime})</code></pre><p>Simulate discrete-time movement path(s) from a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s and a random-walk movement model. </p><p><strong>Arguments (keywords)</strong></p><ul><li><code>xinit</code>: A Vector of initial <a href="#Patter.State"><code>State</code></a>s instances;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.State"><code>State</code></a> refers to the (<code>x</code>, <code>y</code>) location of an animal (alongside additional state components, if applicable). To simulate initial states, use <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a>. For each initial state, <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> simulates a sequence of <a href="#Patter.State"><code>State</code></a>s (i.e., a movement path) of <code>length(timeline)</code> steps using the movement model (<code>model_move</code>). The simulation of movement from one <a href="#Patter.State"><code>State</code></a> into another is implemented by the internal function <a href="#Patter.simulate_move"><code>simulate_move()</code></a>, which in turn wraps <a href="#Patter.simulate_step"><code>simulate_step()</code></a>. At each time step, <a href="#Patter.simulate_move"><code>simulate_move()</code></a> implements <a href="#Patter.simulate_step"><code>simulate_step()</code></a> iteratively until a valid movement is identified (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). <a href="#Patter.simulate_step"><code>simulate_step()</code></a> is a generic function. Methods are implemented for the built-in <a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types but custom sub-types require a corresponding <a href="#Patter.simulate_step"><code>simulate_step()</code></a> method. </p><p><strong>Returns</strong></p><ul><li>A <code>matrix</code> of <a href="#Patter.State"><code>State</code></a>s:<ul><li>Each row represents a simulated path;</li><li>Each column represents a time step along <code>timeline</code>;</li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> to simulate animal movement paths (via <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> to simulate observations arising from simulated movements (via <a href="#Patter.ModelObs"><code>ModelObs</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/006-data-simulation.jl#L5-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_state_init" href="#Patter.simulate_state_init"><code>Patter.simulate_state_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_state_init(state_type::Type{&lt;:State}, model_move::ModelMove, xlim, ylim)</code></pre><p>Simulate a (tentative) initial <a href="#Patter.State"><code>State</code></a> for an animal.</p><p><strong>Arguments:</strong></p><ul><li><code>state_type</code>: An empty <a href="#Patter.State"><code>State</code></a> sub-type, such as <a href="#Patter.StateXY"><code>StateXY</code></a>, used for method dispatch only;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>xlim</code>, <code>ylim</code>: Pairs of numbers that define the boundaries of the area within which initial (<code>x</code>, <code>y</code>) coordinates are sampled;</li></ul><p><strong>Details</strong></p><p>An initial <a href="#Patter.State"><code>State</code></a> defines the initial (<code>x</code>, <code>y</code>) location of an animal, plus initial values for any other <a href="#Patter.State"><code>State</code></a> components (such as the animal&#39;s initial bearing, for <a href="#Patter.StateXYZD"><code>StateXYZD</code></a>). The purpose of <a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a> is to simulate an initial instance of a <a href="#Patter.State"><code>State</code></a>. This is wrapped by the exported function <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a>, which simulates a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s iteratively until <code>n</code> valid <a href="#Patter.State"><code>State</code></a>s are simulated (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). Initial <a href="#Patter.State"><code>State</code></a>s are required to initialise the simulation of individual movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). </p><p><a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a> is an internal generic function, with methods for the built-in <a href="#Patter.State"><code>State</code></a> sub-types. For custom <a href="#Patter.State"><code>State</code></a> sub-types, write a corresponding <a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a> function to use the exported <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> function. </p><p><strong>Returns</strong></p><ul><li>A <a href="#Patter.State"><code>State</code></a> instance;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> for <a href="#Patter.State"><code>State</code></a> sub-types;</li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract</code></a> to extract values from <code>map</code> at <a href="#Patter.State"><code>State</code></a> coordinates;</li><li><a href="#Patter.is_valid"><code>is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a> to simulate an initial <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s, iteratively until <code>n</code> valid <a href="#Patter.State"><code>State</code></a>s are simulated;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use initial <a href="#Patter.State"><code>State</code></a>s to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L96-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_states_init-Tuple{}" href="#Patter.simulate_states_init-Tuple{}"><code>Patter.simulate_states_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_states_init(; state_type::Type{&lt;:State}, model_move::ModelMove, n::Int, xlim, ylim)</code></pre><p>Simulate a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s for the simulation of movement paths.</p><p><strong>Arguments (keywords)</strong></p><ul><li><code>state_type</code>: An empty <a href="#Patter.State"><code>State</code></a> sub-type, such as <code>StateXY</code>, used for method dispatch only;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>n</code>: An integer that defines number of initial states to simulate;</li><li><code>xlim</code>, <code>ylim</code>: (optional) Pairs of numbers that define the boundaries of the area within initial (<code>x</code>, <code>y</code>) coordinates are sampled;</li></ul><p><strong>Details</strong></p><p>An initial <a href="#Patter.State"><code>State</code></a> defines the initial (<code>x</code>, <code>y</code>) location of an animal, plus initial values for any other <a href="#Patter.State"><code>State</code></a> components (such as the animal&#39;s initial bearing, for <a href="#Patter.StateXYZD"><code>StateXYZD</code></a>). The purpose of <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> is to simulate a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a> instances. This wraps the internal generic function <a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a>, iteratively simulating initial <a href="#Patter.State"><code>State</code></a>s until <code>n</code> valid <a href="#Patter.State"><code>State</code></a>s are simulated (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). For custom <a href="#Patter.State"><code>State</code></a> sub-types, a corresponding <a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a> method is required to use this function. Initial <a href="#Patter.State"><code>State</code></a>s are required to initialise the simulation of individual movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). </p><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of <code>n</code> <a href="#Patter.State"><code>State</code></a> instances;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract</code></a> to extract values from <code>map</code> at <a href="#Patter.State"><code>State</code></a> coordinates;</li><li><a href="#Patter.is_valid"><code>is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_state_init"><code>simulate_state_init()</code></a> to simulate an initial <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s, iteratively until <code>n</code> valid <a href="#Patter.State"><code>State</code></a>s are simulated;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use initial <a href="#Patter.State"><code>State</code></a>s to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L147-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_step" href="#Patter.simulate_step"><code>Patter.simulate_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_step(state::State, model_move::ModelMove, t::Int64)</code></pre><p>Simulate a (tentative) step from one location (<a href="#Patter.State"><code>State</code></a>) into a new location (<a href="#Patter.State"><code>State</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines the animal&#39;s previous <a href="#Patter.State"><code>State</code></a>;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.simulate_step"><code>simulate_step()</code></a> is an internal generic function that simulates a new value for the animal&#39;s [<code>State</code>], that is, the animal&#39;s location (and other state components). Methods are provided for the built-in [<code>State</code>] and movement model (<a href="#Patter.ModelMove"><code>ModelMove</code></a>) sub-types. For custom <a href="#Patter.State"><code>State</code></a>s or <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types, corresponding methods must be provided. Internally, <a href="#Patter.simulate_step"><code>simulate_step()</code></a> is wrapped by <a href="#Patter.simulate_move"><code>simulate_move()</code></a>, which implements<a href="#Patter.simulate_step"> <code>simulate_step()</code></a> iteratively until a valid <a href="#Patter.State"><code>State</code></a> is simulated (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). </p><p><strong>Returns</strong></p><ul><li>A <a href="#Patter.State"><code>State</code></a> instance;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L211-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_yobs-Tuple{}" href="#Patter.simulate_yobs-Tuple{}"><code>Patter.simulate_yobs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_yobs(; paths::Matrix, model_obs::Vector{ModelObs}, timeline::Vector{DateTime})</code></pre><p>For a series of simulated paths, simulate a dictionary of observations. </p><p><strong>Arguments</strong></p><ul><li><code>paths</code>: A <code>Matrix</code> of simulated paths from <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>;</li><li><code>model_obs</code>: A Vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances;</li><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li></ul><p><strong>Details</strong></p><p>The function expects a <code>Matrix</code> of simulated paths (see <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>). For each simulated path, the function iterates over each step in <code>timeline</code> and simulates observations using the <code>Vector</code> of observation models. Observations are simulated by the internal generic <a href="#Patter.simulate_obs"><code>simulate_obs()</code></a> via <code>simulate_obs(State, model, t)</code>, where <code>t</code> is the time step. Methods are provided for the built-in <a href="#Patter.State"><code>State</code></a>s and <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types. For custom sub-types, a corresponding <a href="#Patter.simulate_obs"><code>simulate_obs()</code></a> method is required. Simulated observations can be used in the particle filter to reconstruct the underlying movements (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A <code>Dict</code>, with one entry for each path:<ul><li>Each entry is a <code>Dict</code>, with one entry for each time stamp;<ul><li>Each time stamp entry is a <code>Vector</code> of <code>Tuple</code>s, each comprising the simulated observation and the associated <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance (see also <a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a>);</li></ul></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> to simulate animal movement paths (via <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> to simulate observations arising from simulated movements (via <a href="#Patter.ModelObs"><code>ModelObs</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/006-data-simulation.jl#L53-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.two_filter_smoother-Tuple{}" href="#Patter.two_filter_smoother-Tuple{}"><code>Patter.two_filter_smoother</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">two_filter_smoother(; timeline::Vector{DateTime}, xfwd::Matrix, xbwd::Matrix, model_move::ModelMove, box, n_sim::Int)</code></pre><p>A two-filter particle smoother that samples from <code>f(X_t | {Y_1 ... Y_T}) for t ∈ 1:T</code>.</p><p><strong>Arguments (keywords)</strong></p><ul><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li><li><code>xfwd</code>: A <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s from the forward filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li><code>xbwd</code>: A <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s from the backward filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>box</code>: (optional) A <code>NamedTuple</code> (<code>min_x</code>, <code>max_x</code>, <code>min_y</code>, <code>max_y</code>) that defines a &#39;mobility box&#39; (see <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a>);</li><li><code>n_sim</code>: An integer that defines the number of Monte Carlo simulations (see <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a>);</li></ul><p><strong>Details</strong></p><p><a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a> smooths particles from the particle filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). The <code>timeline</code> from the particle filter should be supplied as well as a <code>Matrix</code> of particles from a forward run and a backward run. The two filter smoother works by iteratively resampling particles in line with the probability density of movement between particles from the backward filter at time <code>t</code> and particles from the forward filter at time <code>t - 1</code>. <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> is an internal function that evaluates the log probability of a movement step between particles. This function wraps the <a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> generic. Methods are provided for built-in <a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types. To use custom sub-types, a corresponding <a href="#Patter.logpdf_step"><code>logpdf_step()</code></a> method should be provided. In <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>, the <code>box</code> and <code>n_sim</code> arguments support the calculate of probability densities (see <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a>). </p><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code>, of the same format as returned by <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>, with the following fields:<ul><li><code>timesteps</code></li><li><code>timestamps</code></li><li><code>direction</code>: <code>nothing</code></li><li><code>state</code></li><li><code>ess</code></li><li><code>maxlp</code>: <code>NaN</code></li><li><code>convergence</code>: <code>true</code></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> implements the particle filter;</li><li><a href="#Patter.logpdf_step"><code>logpdf_step()</code></a>, <a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>logpdf_move_normalisation()</code></a> and <a href="#Patter.logpdf_move"><code>logpdf_move()</code></a> evaluate the log probability (density) of movement between two <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a> implements the two-filter particle smoother;</li></ul><p><strong>Source</strong></p><p>Fearnhead, P., Wyncoll, D., Tawn, J., <a href="https://doi.org/10.1093/biomet/asq013">2010</a>. A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447–464.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/008-particle-smoother.jl#L6-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMove" href="#Patter.ModelMove"><code>Patter.ModelMove</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> is an Abstract Type that groups movement models. </p><p><strong>Built-in sub-types</strong></p><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types define the components of different kinds of movement model. The following sub-types are built-in:</p><ul><li><code>ModelMoveXY(map, dbn_length, dbn_angle)</code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (<code>dbn_length</code>) and turning angles (<code>dbn_angle</code>);</li><li><code>ModelMoveXYZD(map, dbn_length, dbn_angle_delta, dbn_z_delta)</code>: A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (<code>dbn_length</code>), changes in turning angle (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li></ul><p>These contain the following fields: </p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. The coordinate reference system of the <code>map</code> must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. <code>map</code> is required by all movement models;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_angle</code>: The distribution of turning angles;</li><li><code>dbn_angle_delta</code>: The distribution of changes in turning angle;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelMoveXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelMove</code>:</p><pre><code class="nohighlight hljs">struct ModelMoveXYZ{T, U, V, W} &lt;: Patter.ModelMove
    # The environment (i.e., map)
    # &gt; This defines the regions within which movements are permitted (i.e., in water)
    map::T
    # Distribution for step lengths
    dbn_length::U
    # Distribution for turning angles
    dbn_angle::V
    # Distribution for changes in depth
    dbn_z_delta::W
  end</code></pre><p>New <a href="#Patter.ModelMove"><code>ModelMove</code></a> structures should obey the following requirements:</p><ul><li>The <code>map</code> field is required by all <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types; </li><li>By default, <code>map</code> is assumed to be a <code>GeoArray</code> but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li></ul><p>To use a new <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.State"><code>State</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L11-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMoveXY" href="#Patter.ModelMoveXY"><code>Patter.ModelMoveXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> is an Abstract Type that groups movement models. </p><p><strong>Built-in sub-types</strong></p><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types define the components of different kinds of movement model. The following sub-types are built-in:</p><ul><li><code>ModelMoveXY(map, dbn_length, dbn_angle)</code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (<code>dbn_length</code>) and turning angles (<code>dbn_angle</code>);</li><li><code>ModelMoveXYZD(map, dbn_length, dbn_angle_delta, dbn_z_delta)</code>: A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (<code>dbn_length</code>), changes in turning angle (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li></ul><p>These contain the following fields: </p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. The coordinate reference system of the <code>map</code> must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. <code>map</code> is required by all movement models;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_angle</code>: The distribution of turning angles;</li><li><code>dbn_angle_delta</code>: The distribution of changes in turning angle;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelMoveXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelMove</code>:</p><pre><code class="nohighlight hljs">struct ModelMoveXYZ{T, U, V, W} &lt;: Patter.ModelMove
    # The environment (i.e., map)
    # &gt; This defines the regions within which movements are permitted (i.e., in water)
    map::T
    # Distribution for step lengths
    dbn_length::U
    # Distribution for turning angles
    dbn_angle::V
    # Distribution for changes in depth
    dbn_z_delta::W
  end</code></pre><p>New <a href="#Patter.ModelMove"><code>ModelMove</code></a> structures should obey the following requirements:</p><ul><li>The <code>map</code> field is required by all <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types; </li><li>By default, <code>map</code> is assumed to be a <code>GeoArray</code> but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li></ul><p>To use a new <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.State"><code>State</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMoveXYZD" href="#Patter.ModelMoveXYZD"><code>Patter.ModelMoveXYZD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> is an Abstract Type that groups movement models. </p><p><strong>Built-in sub-types</strong></p><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types define the components of different kinds of movement model. The following sub-types are built-in:</p><ul><li><code>ModelMoveXY(map, dbn_length, dbn_angle)</code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (<code>dbn_length</code>) and turning angles (<code>dbn_angle</code>);</li><li><code>ModelMoveXYZD(map, dbn_length, dbn_angle_delta, dbn_z_delta)</code>: A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (<code>dbn_length</code>), changes in turning angle (<code>dbn_angle</code>) and changes in depth (<code>dbn_z_delta</code>);</li></ul><p>These contain the following fields: </p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. The coordinate reference system of the <code>map</code> must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. <code>map</code> is required by all movement models;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_angle</code>: The distribution of turning angles;</li><li><code>dbn_angle_delta</code>: The distribution of changes in turning angle;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelMoveXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelMove</code>:</p><pre><code class="nohighlight hljs">struct ModelMoveXYZ{T, U, V, W} &lt;: Patter.ModelMove
    # The environment (i.e., map)
    # &gt; This defines the regions within which movements are permitted (i.e., in water)
    map::T
    # Distribution for step lengths
    dbn_length::U
    # Distribution for turning angles
    dbn_angle::V
    # Distribution for changes in depth
    dbn_z_delta::W
  end</code></pre><p>New <a href="#Patter.ModelMove"><code>ModelMove</code></a> structures should obey the following requirements:</p><ul><li>The <code>map</code> field is required by all <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types; </li><li>By default, <code>map</code> is assumed to be a <code>GeoArray</code> but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li></ul><p>To use a new <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.State"><code>State</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/003-model-movement.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObs" href="#Patter.ModelObs"><code>Patter.ModelObs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/004-model-observation.jl#L9-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObsAcousticLogisTrunc" href="#Patter.ModelObsAcousticLogisTrunc"><code>Patter.ModelObsAcousticLogisTrunc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/004-model-observation.jl#L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObsDepthNormalTrunc" href="#Patter.ModelObsDepthNormalTrunc"><code>Patter.ModelObsDepthNormalTrunc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/004-model-observation.jl#L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObsDepthUniform" href="#Patter.ModelObsDepthUniform"><code>Patter.ModelObsDepthUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong><code>ModelObsDepthUniform</code></strong></p><p><code>ModelObsDepthUniform</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_shallow_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTrunc</code></strong></p><p><code>ModelObsDepthNormalTrunc</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_depth_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a>.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> and to evaluate log probabilities via <a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a>. </p><p><strong>Simulation</strong></p><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><a href="#Patter.simulate_obs"><code>Patter.simulate_obs()</code></a> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs()</code></a> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/004-model-observation.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.State" href="#Patter.State"><code>Patter.State</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new <code>State</code> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/002-states.jl#L3-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.StateXY" href="#Patter.StateXY"><code>Patter.StateXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new <code>State</code> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/002-states.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.StateXYZ" href="#Patter.StateXYZ"><code>Patter.StateXYZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new <code>State</code> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/002-states.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.StateXYZD" href="#Patter.StateXYZD"><code>Patter.StateXYZD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states ;</li><li><code>StateXYZD(map_value, x, y, z, angle)</code>: Used for four-dimensional (x, y, z, direction) states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>angle</code>: A float that defines the turning angle, required by <code>StateXYZD</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <a href="#Patter.r_get_states"><code>Patter.r_get_states()</code></a> to parse state vectors;</li></ul><p>To use a new <code>State</code> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define a <a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init()</code></a> method for <a href="#Patter.simulate_states_init-Tuple{}"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.two_filter_smoother-Tuple{}"><code>two_filter_smoother()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/0cdff396aa7b42978f6c756c75b5ba5f01336cde/src/002-states.jl#L87">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Patter.ModelMove"><code>Patter.ModelMove</code></a></li><li><a href="#Patter.ModelMoveXY"><code>Patter.ModelMoveXY</code></a></li><li><a href="#Patter.ModelMoveXYZD"><code>Patter.ModelMoveXYZD</code></a></li><li><a href="#Patter.ModelObs"><code>Patter.ModelObs</code></a></li><li><a href="#Patter.ModelObsAcousticLogisTrunc"><code>Patter.ModelObsAcousticLogisTrunc</code></a></li><li><a href="#Patter.ModelObsDepthNormalTrunc"><code>Patter.ModelObsDepthNormalTrunc</code></a></li><li><a href="#Patter.ModelObsDepthUniform"><code>Patter.ModelObsDepthUniform</code></a></li><li><a href="#Patter.State"><code>Patter.State</code></a></li><li><a href="#Patter.StateXY"><code>Patter.StateXY</code></a></li><li><a href="#Patter.StateXYZ"><code>Patter.StateXYZ</code></a></li><li><a href="#Patter.StateXYZD"><code>Patter.StateXYZD</code></a></li><li><a href="#Patter.assemble_yobs-Tuple{}"><code>Patter.assemble_yobs</code></a></li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract</code></a></li><li><a href="#Patter.is_valid"><code>Patter.is_valid</code></a></li><li><a href="#Patter.julia_get"><code>Patter.julia_get</code></a></li><li><a href="#Patter.julia_get_model_obs"><code>Patter.julia_get_model_obs</code></a></li><li><a href="#Patter.julia_get_model_obs_types"><code>Patter.julia_get_model_obs_types</code></a></li><li><a href="#Patter.julia_get_xinit"><code>Patter.julia_get_xinit</code></a></li><li><a href="#Patter.logpdf_move"><code>Patter.logpdf_move</code></a></li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}"><code>Patter.logpdf_move_normalisation</code></a></li><li><a href="#Patter.logpdf_obs"><code>Patter.logpdf_obs</code></a></li><li><a href="#Patter.logpdf_step"><code>Patter.logpdf_step</code></a></li><li><a href="#Patter.particle_filter-Tuple{}"><code>Patter.particle_filter</code></a></li><li><a href="#Patter.r_get"><code>Patter.r_get</code></a></li><li><a href="#Patter.r_get_dataset"><code>Patter.r_get_dataset</code></a></li><li><a href="#Patter.r_get_particles"><code>Patter.r_get_particles</code></a></li><li><a href="#Patter.r_get_states"><code>Patter.r_get_states</code></a></li><li><a href="#Patter.resample"><code>Patter.resample</code></a></li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a></li><li><a href="#Patter.simulate_obs"><code>Patter.simulate_obs</code></a></li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>Patter.simulate_path_walk</code></a></li><li><a href="#Patter.simulate_state_init"><code>Patter.simulate_state_init</code></a></li><li><a href="#Patter.simulate_states_init-Tuple{}"><code>Patter.simulate_states_init</code></a></li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step</code></a></li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>Patter.simulate_yobs</code></a></li><li><a href="#Patter.two_filter_smoother-Tuple{}"><code>Patter.two_filter_smoother</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 6 June 2024 13:48">Thursday 6 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
