<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Patter.jl · Patter</title><meta name="title" content="Patter.jl · Patter"/><meta property="og:title" content="Patter.jl · Patter"/><meta property="twitter:title" content="Patter.jl · Patter"/><meta name="description" content="Documentation for Patter."/><meta property="og:description" content="Documentation for Patter."/><meta property="twitter:description" content="Documentation for Patter."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Patter</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Patter.jl</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Patter.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Patter.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/edwardlavender/Patter.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/edwardlavender/Patter.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Patter.jl"><a class="docs-heading-anchor" href="#Patter.jl">Patter.jl</a><a id="Patter.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Patter.jl" title="Permalink"></a></h1><ul><li><a href="#Patter.jl">Patter.jl</a></li><li class="no-marker"><ul><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.assemble_yobs-Tuple{}" href="#Patter.assemble_yobs-Tuple{}"><code>Patter.assemble_yobs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_yobs(; datasets::Vector, model_obs_types::Vector{DataType})</code></pre><p>Assemble a dictionary of observations (and associated model parameters) for the particle filter (<a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). </p><p><strong>Arguments (keywords)</strong></p><ul><li><code>datasets</code>: A <code>Vector</code> of <code>DataFrame</code>s, one for each data type. Each <code>DataFrame</code> must contain the following columns:<ul><li><code>timestamp</code>: A <code>DateTime</code> <code>Vector</code> of time stamps;</li><li><code>sensor_id</code>: A <code>Vector</code> of sensor IDs;</li><li><code>obs</code>: A <code>Vector</code> of observations;</li><li>Additional columns required to construct <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances (that is, model parameters);</li></ul></li><li><code>model_obs_types</code>: A <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types (one for each <code>dataset</code>);</li></ul><p><strong>Details</strong></p><p>The function iterates over animal-tracking datasets (for example, acoustic and archival [depth] time series <em>for a particular individual</em>) and corresponding observation model types and creates a typed dictionary of time stamps for the particle filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>&#39;s <code>yobs</code> argument). Each time step contains a <code>Vector</code> of <code>Tuple</code>s, with one element for each sensor that recorded an observation at that time stamp. For example, each element might correspond to an acoustic receiver and/or the individual&#39;s archival tag. Each element is a <code>Tuple</code> that defines the observation and the corresponding observation model parameters (that is, a <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance). </p><p><strong>Returns</strong></p><ul><li>A <code>Dict</code>:<ul><li>Each element corresponds to a <code>timestamp</code>:<ul><li>Each timestamped element contains a <code>Vector</code> of <code>Tuples</code> (one for each observation):<ul><li>Each <code>Tuple</code> contains an observation and the corresponding <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li></ul></li></ul></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a> to assemble real-world datasets for the particle filter;</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> to simulate observations for the particle filter;</li><li><a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to implement the particle filter;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/006-data-assembly.jl#L41-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}" href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract(map::GeoArrays.GeoArray, x::Real, y::Real)</code></pre><p>(Internal) Extract the value of a <code>GeoArray</code> (such as a bathymetry grid) at a pair of <code>x</code> and <code>y</code> coordinates.</p><p><strong>Details</strong></p><p>In <code>Patter.jl</code>, <code>map</code> is a <code>GeoArray</code> that defines the area within which movements are possible. In our applications, <code>map</code> is often a bathymetry raster that defines the depth of the seabed across the study area. <code>map</code> is an essential field in individual movement models (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>). The internal <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> function supports the simulation of initial states (via <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a>) and the updating of states (via <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a>), as required to simulate animal movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). Individual states define, at a minimum, the individual&#39;s location (<code>x</code>, <code>y</code>) and the value of the map at that location (<code>map_value</code>), which is extracted by <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> (see <a href="#Patter.State"><code>State</code></a>). The Coordinate Reference Systems for <code>map</code>, <code>x</code> and <code>y</code> must align for this to work (i.e., <code>map</code> should use a Universal Transverse Mercator projection with coordinates in metres). <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> is exported so that it can be used in new methods (for custom states or movement models) of these functions. The simulation of individual movements (via <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a>) is implemented iteratively (via <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) until a valid movement is found. <code>NaN</code> is taken to define inhospitable habitats, such as land, into which the individual cannot move (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). It should be possible to use a <code>map</code> in another format (such as a shapefile) within these routines, with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method that returns <code>NaN</code> in inhospitable habitats and a numeric constant otherwise. </p><p><strong>Returns</strong></p><ul><li>The value of the <code>GeoArray</code> for a coordinate pair within the bounds of <code>map</code>;</li><li>NaN (of the same type as <code>map</code>&#39;s elements) for a coordinate pair beyond the bounds of <code>map</code>;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> for <a href="#Patter.State"><code>State</code></a> sub-types;</li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract()</code></a> to extract values from <code>map</code> at <a href="#Patter.State"><code>State</code></a> coordinates;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>Patter.is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/002-spatial.jl#L80-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.is_valid" href="#Patter.is_valid"><code>Patter.is_valid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_valid(map_value::Real)
is_valid(map_value::Real, z::Real)</code></pre><p>(Internal) Determine the validity of a point on a <code>map</code>.</p><p>For two-dimensional (x, y) states, <code>is_valid(map_value)</code> checks if the <code>map_value</code> (at a point (<code>x</code>, <code>y</code>)) is not <code>NaN</code>.</p><p>For states with a depth (<code>z</code>) component, <code>is_valid(map_value, z)</code>, checks that <code>map_value</code> is not <code>NaN</code> and that the provided z-coordinate (<code>z</code>) lies within the valid range, specifically <code>0 &lt; z ≤ map_value</code> (i.e., the animal is not below the seabed).</p><p><strong>Arguments</strong></p><ul><li><code>map_value</code>: The value of the <code>map</code> in a particular location;</li><li><code>z</code>: (optional) The z-coordinate (depth) of the animal, used for states that contain a depth component only;</li></ul><p><strong>Details</strong></p><p>These are internal functions. They are used to validate simulated individual states (see <a href="#Patter.State"><code>State</code></a>). Individual states (i.e., locations) are simulated via <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a>. <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> wraps <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a>, iteratively proposing states until a valid state is found. This is required to simulate animal movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li><code>true</code> if the conditions for validity are met;</li><li><code>false</code> otherwise;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> for <a href="#Patter.State"><code>State</code></a> sub-types;</li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract()</code></a> to extract values from <code>map</code> at <a href="#Patter.State"><code>State</code></a> coordinates;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>Patter.is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/002-spatial.jl#L116-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}" href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logpdf_move(state_from::State, state_to::State, state_zdim::Bool, 
            model_move::ModelMove, 
            t::Int, 
            vmap::Union{GeoArray, Nothing}, 
            n_sim::Int,
            cache::Union{Dict, Nothing})</code></pre><p>(Internal) Evaluate the log probability of a movement between two <a href="#Patter.State"><code>State</code></a>s (<code>state_from</code> and <code>state_to</code>). </p><p><strong>Arguments</strong></p><ul><li><code>state_from</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> from which the animal moved;</li><li><code>state_to</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> into which the animal moved;</li><li><code>state_zdim</code>: A <code>Boolian</code> that defines whether or not <code>state_from</code> and <code>state_to</code> contain a <code>z</code> (depth) dimension;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>vmap</code>: (optional) A <code>GeoArray</code> that maps the region within which movements from <code>state_from</code> are always legal. Valid regions must equal 1. <code>vmap</code> can be provided for &#39;horizontal&#39; movement models (e.g., if <code>state_from</code> and <code>state_to</code> are <code>StateXY</code> instances (see <a href="#Patter.State"><code>State</code></a>));</li><li><code>n_sim</code>: An integer that defines the number of Monte Carlo simulations (used to approximate the normalisation constant);</li><li><code>cache</code>: (optional) A Dict of normalisation constants including <code>state_from</code>;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> is an internal function that evaluates the log probability of a movement step between two <a href="#Patter.State"><code>State</code></a>(s) (i.e., locations). This function wraps <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a>, accounting for accounting for restrictions to movement; that is, <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> evaluates <code>logpdf_step(state_from, state_to, model_move, t, length, heading) + log(abs(determinate)) - log(Z)</code> where <code>Z</code> is the normalisation constant. If <code>model_move</code> is &#39;horizontal (e.g., <code>state_from</code> and <code>state_to</code> are two-dimensional, <code>StateXY</code> instances), a &#39;validity map&#39; (<code>vmap</code>) can be provided. This is a <code>GeoArray</code> that define the regions within which movements between two locations are always legal. In the case of an aquatic animal, this is the region of the study area that is the sea, shrunk by <code>state_from.mobility</code>. In this instance, the normalisation constant is simply <code>log(1.0)</code>. Otherwise, a Monte Carlo simulation of <code>n_sim</code> iterations is required to approximate the normalisation constant, accounting for invalid movements, which is more expensive (see <a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>logpdf_move_normalisation()</code></a>). Set <code>n_sim = 0</code> and <code>cache = nothing</code> for unrestricted models (i.e., if <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> was implemented with <code>n_move = 1</code>). <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> is used for particle smoothing (see <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A number (log probability); </li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> and <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> to evaluate the log-probability of movement between two locations;</li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>Patter.logpdf_move_normalisation()</code></a> for estimation of the normalisation constant;</li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> for the front-end function that uses these routines for particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/004-model-movement.jl#L314-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}" href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>Patter.logpdf_move_normalisation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logpdf_move_normalisation(state::State, state_zdim::Bool, 
                          model_move::ModelMove, t::Int, 
                          vmap::Union{GeoArray, Nothing},
                          n_sim::Int)</code></pre><p>(Internal) Approximate the (log) normalisation constant for the (log) probability density of movement from one <a href="#Patter.State"><code>State</code></a> (location) into another. </p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> from which the animal moved;</li><li><code>state_zdim</code>: A <code>Boolian</code> that defines whether or not <code>state</code> contains a <code>z</code> (depth) dimension;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>vmap</code>: (optional) A <code>GeoArray</code> that maps the region within which movements from <code>state</code> are always legal. Valid regions must equal 1. <code>vmap</code> can be provided for &#39;horizontal&#39; movement models (e.g., if <code>state</code> is a <code>StateXY</code>);</li><li><code>n_sim</code>: An integer that defines the number of Monte Carlo simulations. Set <code>n_sim = 0</code> if <code>n_move = 1</code> in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>;</li></ul><p><strong>Details</strong></p><p>This internal function computes the normalisation constant for the (log) probability of movement from one <a href="#Patter.State"><code>State</code></a> (<code>state</code>) into another. If <code>n_move = 1</code> in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>, set <code>n_sim = 0</code> to return <code>log(1.0)</code>. Otherwise, we need to account for the truncation of the movement model by land. If <code>model_move</code> is &#39;horizontal&#39; (e.g., <code>state</code> is a two-dimensional, <code>StateXY</code> instance), a &#39;validity map&#39; (<code>vmap</code>) can be provided. This is a <code>GeoArray</code> that define the regions within which movements from that <code>state</code> are always legal. In the case of an aquatic animal, this is the region of the study area that is the sea, shrunk by <code>state.mobility</code>. In this instance, the normalisation constant is simply <code>log(1.0)</code>. Otherwise, a Monte Carlo simulation of <code>n_sim</code> iterations is used to estimate the normalisation constant. A Beta(1, 1) prior is used to correct for simulations that fail to generate valid move from <code>state</code>. This function is used by <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> to evaluate the (log) probability of movement between two states, which is required for particle smoothing (see <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A number (the log normalisation constant); </li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> and <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> to evaluate the log-probability of movement between two locations;</li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>Patter.logpdf_move_normalisation()</code></a> for estimation of the normalisation constant;</li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> for the front-end function that uses these routines for particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/004-model-movement.jl#L393-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.logpdf_step" href="#Patter.logpdf_step"><code>Patter.logpdf_step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logpdf_step(state_from::State, state_to::State, model_move::ModelMove, length, heading)</code></pre><p>(Internal) Evaluate the (unnormalised) log probability of an (unrestricted) movement step. </p><p><strong>Arguments</strong></p><ul><li><code>state_from</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> from which the animal moved;</li><li><code>state_to</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines a <a href="#Patter.State"><code>State</code></a> into which the animal moved;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>length</code>: A float that defines the step length (i.e., the Euclidean distance between <code>state_from</code> (<code>x</code>, <code>y</code>) and <code>state_to</code> (<code>x</code>, <code>y</code>));</li><li><code>heading</code>: A float that defines the angle (in polar coordinates) between <code>state_from</code> (<code>x</code>, <code>y</code>) and <code>state_to</code> (<code>x</code>, <code>y</code>);</li></ul><p><strong>Details</strong></p><p><a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> is an internal generic function that evaluates the (unnormalised) log probability of an (unrestricted) movement step between two <a href="#Patter.State"><code>State</code></a>(s) (i.e., locations). Methods are provided for the built-in <a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types, but need to be provided for custom sub-types. Internally, <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> is wrapped by <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>, which evaluates the log probability of movement between two <a href="#Patter.State"><code>State</code></a>s, accounting for restrictions to movement; that is, <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> evaluates <code>logpdf_step(state_from, state_to, model_move, length, heading) + log(abs(determinate)) - log(Z)</code> where <code>Z</code> is the normalisation constant. This is required for particle smoothing (see <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A number (log probability); </li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> and <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> to evaluate the log-probability of movement between two locations;</li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>Patter.logpdf_move_normalisation()</code></a> for estimation of the normalisation constant;</li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> for the front-end function that uses these routines for particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/004-model-movement.jl#L256-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.particle_filter-Tuple{}" href="#Patter.particle_filter-Tuple{}"><code>Patter.particle_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particle_filter(; timeline::Vector{DateTime},
                  xinit::Vector{&lt;:State},
                  yobs::Dict,
                  model_move::ModelMove,
                  n_move::Int = 100_000,
                  n_record::Int = 1000,
                  n_resample::Float64 = Float64(n_record),
                  t_resample::Union{Nothing, Int, Vector{Int}}  = nothing,
                  n_iter::Int64 = 1,
                  direction::String = &quot;forward&quot;, 
                  batch::Union{Nothing, Vector{String}} = nothing, 
                  progress = (), 
                  verbose::Bool = true)</code></pre><p>A particle filtering algorithm that samples from <code>f(s_t | y_{1:t})</code> for <code>t ∈ 1:t</code>.</p><p><strong>Arguments (keywords)</strong></p><ul><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li><li><code>xinit</code>: A <code>Vector</code> of <a href="#Patter.State"><code>State</code></a> instances that defines the initial state(s) of the animal;</li><li><code>yobs</code>: A Dictionary of observations:<ul><li>Dictionary keys should match elements in <code>timeline</code>;</li><li>Each element must be a <code>Vector</code> of <code>Tuple</code>s for that time step (one for each observation/sensor);</li><li>Each <code>Tuple</code> should contain (a) the observation and (b) the model parameters (that is, a <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance);</li></ul></li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance:<ul><li>The movement model describes movement from one time step to the next and therefore depends implicitly on the resolution of <code>timeline</code>;</li><li>The movement model should align with the <a href="#Patter.State"><code>State</code></a> instances in <code>xinit</code>. For example, a two-dimensional state (<code>StateXY</code>) requires a corresponding movement model instance (i.e., <code>ModelMoveXY</code>);</li></ul></li><li><code>n_move</code>: An integer that defines the number of attempts used to find a legal move;<ul><li>All <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types contain a <code>map</code> field that defines the region(s) within which movements are allowed (see <a href="#Patter.is_valid"><code>is_valid()</code></a>);</li><li>Each particle is moved up to <code>n_move</code> times, until a valid movement is simulated;</li><li>Particles that fail to generate a valid move are killed;</li><li><code>n_move = 1</code> is permitted, which corresponds to an &#39;unrestricted&#39; movement model in which particles are instantly killed if they land in inhospitable habitats on <code>map</code>;</li></ul></li><li><code>n_record</code>: An integer that defines the number of particles to record at each time step:<ul><li><code>n_record</code> particles are resampled at each time step and recorded in memory;</li></ul></li><li><code>n_resample</code>: A number that defines the effective sample size for resampling:<ul><li>Particles are resampled when the effective sample size &lt;= <code>n_resample</code>;</li></ul></li><li><code>t_resample</code>: <code>nothing</code>, an <code>integer</code> or a Vector of <code>integer</code>s that define the time step(s) at which to force resampling;<ul><li>Particles are resampled at <code>t_resample</code> regardless of the effective sample size;</li></ul></li><li><code>n_iter</code>: A integer that defines the maximum number of iterations (trials);</li><li><code>direction:</code> A <code>String</code> that defines the direction of the filter:<ul><li><code>&quot;forward&quot;</code> runs the filter forwards in time;</li><li><code>&quot;backward&quot;</code> runs the filter backwards in time;</li></ul></li><li>(optional) <code>batch</code>: A Vector of <code>.jld2</code> file paths for particles (see Memory Management);</li><li>(optional) <code>progress</code>: A NamedTuple of arguments, passed to <code>ProgressMeter.Progress</code>, to control the progress bar. If enabled, one progress bar is shown for each batch;</li><li><code>verbose</code>: A <code>Bool</code> that defines whether or not to print information to the console;</li></ul><p><strong>Algorithm</strong></p><p><strong>Initiation</strong></p><p>The algorithm is initiated using a <code>Vector</code> of <code>n_particle</code> <a href="#Patter.State"><code>State</code></a>s (<code>xinit</code>). See <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states for the filter.</p><p><strong>Movement</strong></p><p>For every time step in the <code>timeline</code>, the internal function <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> simulates the movement of particles away from previous <a href="#Patter.State"><code>State</code></a>s into new <a href="#Patter.State"><code>State</code></a>s using the movement model, as specified by <code>model_move</code>. <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> is an iterative wrapper for a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method that simulates a new <a href="#Patter.State"><code>State</code></a> instance from the previous <a href="#Patter.State"><code>State</code></a>. <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> implements <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> iteratively until a legal move is found (or <code>n_move</code> is reached). For custom <a href="#Patter.State"><code>State</code></a> or <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types, a corresponding <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method is required. Illegal moves are those that land in <code>NaN</code> locations on the <code>map</code> or, in the case of <a href="#Patter.State"><code>State</code></a>s that include a depth (<code>z</code>) component, are below the depth of the seabed (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). Particles that fail to generate legal moves are eventually killed by re-sampling (see below).</p><p><strong>Likelihood</strong></p><p>Observations are used to weight simulated particles. To simulate observations for filtering, use <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a>. To assemble real-world observations for filtering, see <a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a>. For each valid <a href="#Patter.State"><code>State</code></a> and time stamp in <code>yobs</code>, the log-probability of each observation, given the <a href="#Patter.State"><code>State</code></a>, is evaluated via <code>Patter.logpdf_obs()</code>. For custom <a href="#Patter.State"><code>State</code></a> or <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types, a corresponding <code>Patter.logpdf_obs()</code> method is required. The maximum weight across all particles (<code>maxlp</code>) is recorded at each time step as an algorithm diagnostic. (This metric can be intepreted as the maximum log-posterior if resampling is implemented at every time step.)</p><p><strong>Resampling</strong></p><p>Particles are periodically re-sampled, with replacement, using the low-variance systematic re-sampling algorithm (via <a href="#Patter.resample"><code>Patter.resample()</code></a>), at time steps in <code>t_resample</code> or when the effective sample size is less than or equal to <code>n_resample</code>. This has the effect of eliminating impossible particles and duplicating likely ones.</p><p>The algorithm continues in this way, iterating over the <code>timeline</code>, simulating, weighting and (re)sampling particles. At each time step, <code>n_record</code> particles are saved in memory. If the function fails to converge, a warning is returned alongside the outputs up to that time step. Otherwise, the function will continue to the end of the time series.</p><p><strong>Multi-threading</strong></p><p>The iteration over particles (i.e., simulated movements and likelihood evaluations) are multi-threaded.</p><p><strong>Memory management</strong></p><p>By default, <code>n_record</code> particles at each time step are retained in memory. If <code>batch</code> is provided, the <code>timeline</code> is split into <code>length(batch)</code> batches. The filter still moves along the whole <code>timeline</code>, but only records the particles for the current batch in memory. At the end of each batch, the particles for that batch are written to file. This reduces total memory demand. </p><p><code>batch</code> file paths are sorted alphanumerically if <code>direction = &quot;forward&quot;</code> and in reverse order if <code>direction = &quot;backward&quot;</code>. For example: </p><ul><li>If you have a <code>timeline</code> of 10 time steps, <code>direction = &quot;forward&quot;</code> and <code>batch = [&quot;fwd-1.jld2&quot;, &quot;fwd-2.jld2&quot;, &quot;fwd-3.jld2&quot;]</code>, <code>fwd-1.jld2</code>, <code>fwd-2.jld2</code> and <code>fwd-3.jld2</code> contain the particle matrices for time steps <code>[1, 2, 3]</code>, <code>[4, 5, 6]</code> and [<code>7, 8, 9, 10</code>], respectively. </li><li>If you have a <code>timeline</code> of 10 time steps, <code>direction = &quot;backward&quot;</code> and <code>batch = [&quot;bwd-1.jld2&quot;, &quot;bwd-2.jld2&quot;, &quot;bwd-3.jld2&quot;]</code>, <code>bwd-1.jld2</code>, <code>bwd-2.jld2</code> and <code>bwd-3.jld2</code> similarly contain the particle matrices for time steps <code>[1, 2, 3]</code>, <code>[4, 5, 6]</code> and [<code>7, 8, 9, 10</code>], respectively. </li></ul><p><strong>Convergence and diagnostics</strong></p><p>Algorithm convergence is not guaranteed. The algorithm may reach a dead-end–-a time step at which there are no valid locations into which the algorithm can step. This may be due to data errors, incorrect assumptions, insufficient sampling effort or poor tuning-parameter settings.</p><p><strong>Returns</strong></p><ul><li>A <a href="#Patter.Particles"><code>Particles</code></a> structure;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a>, <a href="#Patter.ModelMove"><code>ModelMove</code></a> and <a href="#Patter.ModelObs"><code>ModelObs</code></a> for <a href="#Patter.State"><code>State</code></a>, movement model and observation model sub-types;</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> and <a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a> to prepare observations for the particle filter;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> for the internal routines used to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><code>Patter.logpdf_obs()</code> methods to evaluate the log probability of observations;</li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> to implement particle smoothing;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/009-particle-filter.jl#L327-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.particle_smoother_two_filter-Tuple{}" href="#Patter.particle_smoother_two_filter-Tuple{}"><code>Patter.particle_smoother_two_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particle_smoother_two_filter(; timeline::Vector{DateTime}, 
                               xfwd::Union{Matrix{&lt;:State}, Vector{String}}, 
                               xbwd::Union{Matrix{&lt;:State}, Vector{String}}, 
                               model_move::ModelMove, 
                               vmap::Union{GeoArray, Nothing} = nothing, 
                               n_sim::Int = 100, 
                               n_particle::Union{Nothing, Int} = nothing,
                               cache::Bool = true, 
                               batch::Union{Nothing, Vector{String}} = nothing, 
                               progress = true, 
                               verbose::Bool = true)</code></pre><p>A two-filter particle smoother that samples from <code>f(s_t | y_{1:T})</code> for <code>t ∈ 1:T</code>.</p><p><strong>Arguments (keywords)</strong></p><ul><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li><li><code>xfwd</code>, <code>xbwd</code>: Particles from the forward and backward filters (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>), supplied as:<ul><li>A <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s (in memory);</li><li>A <code>Vector</code> of file paths, if <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> was implemented with <code>batch</code>;</li></ul></li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>vmap</code>: (optional) A <code>GeoArray</code> that defines the &#39;validity map&#39; (see <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>);</li><li><code>n_sim</code>: An integer that defines the number of Monte Carlo simulations (see <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>);</li><li>(optional) <code>n_particle</code>: An integer that defines the number of particles for smoothing. If <code>nothing</code>, all particles are used;</li><li><code>cache</code>: A <code>Bool</code> that defines whether or not to precompute and cache movement density normalisation constants (see <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>);</li><li>(optional) <code>batch</code>: A <code>Vector</code> of <code>.jld2</code> file paths for particles (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>(optional) <code>progress</code>: A NamedTuple of arguments, passed to <code>ProgressMeter.Progress</code>, to control the progress bar. If enabled, one progress bar is shown for each batch;</li><li><code>verbose</code>: A <code>Bool</code> that defines whether or not to print information to the console;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> smooths particles from the particle filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>). The <code>timeline</code> from the particle filter should be supplied as well as a <code>Matrix</code> of particles from a forward run and a backward run (or a <code>Vector</code> of file paths to those matrices). The two filter smoother works by iteratively resampling particles in line with the probability density of movement between particles from the backward filter at time <code>t</code> and particles from the forward filter at time <code>t - 1</code>. <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> is an internal function that evaluates the log probability of a movement step between particles. This function wraps the <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> generic. Methods are provided for built-in <a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types. To use custom sub-types, a corresponding <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method should be provided. In <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>, the <code>vmap</code> and <code>n_sim</code> arguments support the calculate of probability densities (see <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>). For movement models for which the density only depends on fields in <code>xbwd</code> and <code>xfwd</code>, set <code>cache = true</code> to precompute and store normalisation constants for density calculations for unique <code>xbwd</code> elements. Note that since typically only a subsample of particles from <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> are retained in memory, it is not guaranteed that valid moves will exist between particle pairs at all time steps. At time step(s) in which the two filters are incompatible, 50 % of particles are retained from the forward filter and 50 % from the backward filter with a warning. The effective sample size at such time steps is set to <code>NaN</code>, providing an index and counter for problematic time steps (see Returns). Batching is only implemented if the inputs (<code>xfwd</code>, and <code>xbwd</code>) and outputs (via <code>batch</code>) are batched (and contain the same number of batches). </p><p><strong>Returns</strong></p><ul><li>A <a href="#Patter.Particles"><code>Particles</code></a> structure;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> implements the particle filter;</li><li><a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a>, <a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>logpdf_move_normalisation()</code></a> and <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a> evaluate the log probability (density) of movement between two <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> implements the two-filter particle smoother;</li></ul><p><strong>Source</strong></p><p>Fearnhead, P., Wyncoll, D., Tawn, J., <a href="https://doi.org/10.1093/biomet/asq013">2010</a>. A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447–464.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/010-particle-smoother.jl#L168-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.resample" href="#Patter.resample"><code>Patter.resample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resample(w::Vector{Float64}, n::Int)</code></pre><p>(Internal) Given a weight vector <code>w</code>, resample a set of <em>indices</em> based on low-variance resampling algorithm from Thrun, Burgard and Fox&#39;s &quot;Probabilistic Robotics&quot;.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: A <code>Vector{Float64}</code> of weights;</li><li><code>n</code>: An integer that defines the number of particles;</li></ul><p><strong>Details</strong></p><p>This is an internal function that implements systematic resampling in the particle filter (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>) and smoothing algorithms (see <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>). Note that for large <code>n</code>, the function is not numerically stable.</p><p><strong>Returns</strong></p><ul><li>An integer vector of indices;</li></ul><p><strong>Example</strong></p><pre><code class="language-Julia hljs">X = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
w = [0, 0, 0.75, 0.25]

idx = resample(w, 12)
X[idx]</code></pre><p><strong>Source</strong></p><p>Code adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/009-particle-filter.jl#L83-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_move" href="#Patter.simulate_move"><code>Patter.simulate_move</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_move(state::State, model_move::ModelMove, t::Int64, n_trial::Real)</code></pre><p>(Internal) Simulate movement from one location (<a href="#Patter.State"><code>State</code></a>) into a new location (<a href="#Patter.State"><code>State</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines the animal&#39;s previous <a href="#Patter.State"><code>State</code></a>;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>n_trial</code>: A number that defines the number of attempts to simulate a valid <a href="#Patter.State"><code>State</code></a>;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> is an internal function that uses a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method to simulate new state proposals iteratively until a valid <a href="#Patter.State"><code>State</code></a> is generated or <code>n_trial</code> is reached (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). For custom <a href="#Patter.State"><code>State</code></a>s or <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types, corresponding <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> methods must be provided for this function. <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> is used to simulate movement paths (e.g., in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A <code>Tuple</code> that comprises the simulated <a href="#Patter.State"><code>State</code></a> instance and the (log) weight; i.e., <ul><li><code>([State], 0.0)</code> if <a href="#Patter.State"><code>State</code></a> is valid;</li><li><code>([State], -Inf)</code> if <a href="#Patter.State"><code>State</code></a> is invalid;</li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>Patter.is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/004-model-movement.jl#L197-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_path_walk-Tuple{}" href="#Patter.simulate_path_walk-Tuple{}"><code>Patter.simulate_path_walk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_path_walk(; xinit = Vector, model_move::ModelMove, timeline::Vector{DateTime})</code></pre><p>Simulate discrete-time movement path(s) from a <code>Vector</code> of initial <a href="#Patter.State"><code>State</code></a>s and a random-walk movement model. </p><p><strong>Arguments (keywords)</strong></p><ul><li><code>xinit</code>: A Vector of initial <a href="#Patter.State"><code>State</code></a>s instances;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.State"><code>State</code></a> refers to the (<code>x</code>, <code>y</code>) location of an animal (alongside additional state components, if applicable). To simulate initial states, use <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a>. For each initial state, <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> simulates a sequence of <a href="#Patter.State"><code>State</code></a>s (i.e., a movement path) of <code>length(timeline)</code> steps using the movement model (<code>model_move</code>). The simulation of movement from one <a href="#Patter.State"><code>State</code></a> into another is implemented by the internal function <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>, which in turn wraps <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a>. At each time step, <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> implements <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> iteratively until a valid movement is identified (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> is a generic function. Methods are implemented for the built-in <a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types but custom sub-types require a corresponding <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method. </p><p><strong>Returns</strong></p><ul><li>A <code>matrix</code> of <a href="#Patter.State"><code>State</code></a>s:<ul><li>Each row represents a simulated path;</li><li>Each column represents a time step along <code>timeline</code>;</li></ul></li></ul><p><strong>See also</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/007-data-simulation.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_states_init" href="#Patter.simulate_states_init"><code>Patter.simulate_states_init</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_states_init(; map::Rasters.Raster,
                       timeline::Vector{DateTime}, 
                       state_type::Type{&lt;: State}, 
                       xinit::Union{Nothing, DataFrame}, 
                       model_move::ModelMove, 
                       datasets::Union{Nothing, Vector}, 
                       model_obs_types::Union{Nothing, Vector}, 
                       n_particle::Int, 
                       direction::String = &quot;forward&quot;, 
                       output = &quot;DataFrame&quot;)</code></pre><p>Simulate a DataFrame or Vector of initial <a href="#Patter.State"><code>State</code></a>s for the simulation of movement paths in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>map</code>: A <code>Rasters.Raster</code> that defines the study area for the simulation. Here, <code>map</code> is used to:</p><ul><li>Sample initial coordinates, via <code>Patter.coords_init()</code>, if <code>xinit = nothing</code>;</li></ul></li><li><p><code>timeline</code>, <code>model_move</code>, <code>datasets</code>, <code>model_obs_types</code>, <code>direction</code>: Additional arguments used to restrict <code>map</code>, via <code>Patter.map_init()</code>, before sampling initial states.</p><ul><li><code>timeline</code>: A sorted, <code>DateTime</code> vector of regularly spaced time stamps that defines the timeline for the simulation;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li>(optional) <code>datasets</code>: A <code>Vector</code> of observation datasets or <code>nothing</code>;</li><li>(optional) <code>model_obs_types</code>: A <code>Vector</code> of <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types or <code>nothing</code>;</li><li><code>direction</code>: A <code>String</code> string that defines the direction of the simulation (<code>&quot;forward&quot;</code> or <code>&quot;backward&quot;</code>);</li></ul></li><li><p><code>state_type</code>: The <a href="#Patter.State"><code>State</code></a> sub-type. Here, <code>state</code> is used to:</p><ul><li>Convert sampled coordinates to initial states, via <code>Patter.states_init()</code>, if <code>xinit = nothing</code>;</li></ul></li><li><p><code>xinit</code>: (optional) A <code>DataFrame</code> of initial states, with one column for each state dimension.</p></li><li><p><code>n_particle</code>: An <code>integer</code> that defines the number of simulated states:</p><ul><li>If <code>xinit = nothing</code>, <code>n_particle</code> specifies the number of simulated states via <code>Patter.coords_init()</code>;</li><li>If <code>xinit</code> is supplied but there are not <code>n_particle</code> initial states, <code>n_particle</code> initial states are re-sampled from <code>xinit</code> with replacement;</li></ul></li><li><p><code>output</code>: A <code>String</code> that defines the output format:</p><ul><li><code>&quot;DataFrame&quot;</code> returns a <code>DataFrame</code> (for communication with <code>R</code>);</li><li><code>&quot;Vector&quot;</code> returns a Vector of <a href="#Patter.State">`State</a>(s);</li></ul></li></ul><p><strong>Details</strong></p><p>These functions support the simulation of initial states for animal movement walks in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>.</p><p>If <code>xinit = nothing</code>, initial coordinates are sampled from <code>map</code>.</p><p>The region(s) within <code>map</code> from which initial coordinates are sampled can be optionally restricted by the provision of the observation datasets and the associated model sub-types (via <code>Patter.map_init_iter()</code>). This option does not apply to <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> but is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> where observation models are used. In this instance, <code>Patter.map_init_iter()</code> iterates over each model and uses the <code>Patter.map_init()</code> method to update <code>map</code>. The following methods are implemented:</p><ul><li>Default. The default method returns <code>map</code> unchanged.</li><li><code>model_obs_type::ModelObsAcousticLogisTrunc</code>. This method uses acoustic observations to restrict <code>map</code> via Lavender et al.&#39;s (<a href="https://doi.org/10.1111/2041-210X.14193">2023</a>) acoustic–container algorithm. The function identifies the receiver(s) that recorded detection(s) immediately before, at and following the first time step (<code>timeline[start]</code>, where <code>start</code> is <code>1</code> if <code>direction = &quot;forward&quot;</code> and <code>length(timeline)</code> otherwise). The &#39;container&#39; within which the individual must be located from the perspective of each receiver is defined by the time difference and the individual&#39;s mobility (that is, the maximum moveable distance the individual could move between two time steps), which must be specified in <code>model_move.mobility</code>. The intersection between all containers defines the possible locations of the individual at the first time step.</li><li><code>model_obs_type::ModelObsDepthUniformSeabed</code>. This method uses the depth observations to restrict <code>map</code> (which should represent the bathymetry in a region). The individual must be within a region in which the observed depth at <code>timeline[start]</code> is within a depth envelope around the bathymetric depth defined by the parameters <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> (see <a href="#Patter.ModelObs"><code>ModelObs</code></a>). (If there is no observation at <code>timeline[start]</code>, <code>map</code> is returned unchanged.)</li><li><code>model_obs_type::ModelObsDepthNormalTruncSeabed</code>. This method also uses depth observations to restrict <code>map</code>. The individual must be in a location where the bathymetric depth plus the <code>depth_deep_eps</code> parameter at <code>timeline[start]</code> is greater than or equal to the observed depth at <code>timeline[start]</code> (see <a href="#Patter.ModelObs"><code>ModelObs</code></a>). (If there is no observation at <code>timeline[start]</code>, <code>map</code> is returned unchanged.)</li></ul><p>To handle custom <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types, process <code>map</code> beforehand or write an appropriate <code>Patter.map_init()</code> method.</p><p>Using <code>map</code>, a <code>DataFrame</code> of <code>n_particle</code> initial coordinates (<code>map_value</code>, <code>x</code>, <code>y</code>) is sampled using <code>Patter.coords_init()</code>. Additional state dimensions are added, as required depending on the <code>state_type</code>, via a <code>Patter.states_init()</code> method. For custom <a href="#Patter.State"><code>State</code></a> sub-types, a corresponding <code>Patter.states_init()</code> method is required (or supply <code>xinit</code> yourself).</p><p>If <code>xinit()</code> is provided and <code>n_particle</code> initial states are provided, <code>xinit</code> is returned unchanged. Otherwise, <code>n_particle</code> initial states are resampled from <code>xinit</code>, with replacement, and returned.</p><p><strong>Returns</strong></p><p><a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> returns:</p><ul><li>If <code>output = &quot;DataFrame&quot;</code>, a <code>DataFrame</code>, with <code>n_particle</code> rows, and one column for each <a href="#Patter.State"><code>State</code></a> dimension;</li><li>If <code>output = &quot;Vector&quot;</code>, a <code>Vector</code> of <a href="#Patter.State"><code>State</code></a> instances, with <code>n_particle</code> elements;</li></ul><p><strong>See also</strong></p><p>These functions are used to initialise simulated movement trajectories in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>. See also:</p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> to simulate animal movement paths (via <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> to simulate observations arising from simulated movements (via <a href="#Patter.ModelObs"><code>ModelObs</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/008-particle-filter-initialise.jl#L7-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_step" href="#Patter.simulate_step"><code>Patter.simulate_step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_step(state::State, model_move::ModelMove, t::Int64)</code></pre><p>(Internal) Simulate a (tentative) step from one location (<a href="#Patter.State"><code>State</code></a>) into a new location (<a href="#Patter.State"><code>State</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance that defines the animal&#39;s previous <a href="#Patter.State"><code>State</code></a>;</li><li><code>model_move</code>: A <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p><strong>Details</strong></p><p><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> is an internal generic function that simulates a new value for the animal&#39;s [<code>State</code>], that is, the animal&#39;s location (and other state components). Methods are provided for the built-in [<code>State</code>] and movement model (<a href="#Patter.ModelMove"><code>ModelMove</code></a>) sub-types. For custom <a href="#Patter.State"><code>State</code></a>s or <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types, corresponding methods must be provided. Internally, <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> is wrapped by <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>, which implements<a href="#Patter.simulate_step"> <code>simulate_step()</code></a> iteratively until a valid <a href="#Patter.State"><code>State</code></a> is simulated (see <a href="#Patter.is_valid"><code>is_valid()</code></a>). </p><p><strong>Returns</strong></p><ul><li>A <a href="#Patter.State"><code>State</code></a> instance;</li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> to simulate a new <a href="#Patter.State"><code>State</code></a>;</li><li><a href="#Patter.is_valid"><code>Patter.is_valid()</code></a> to determine whether or not a simulated state is valid;</li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate states iteratively until a valid state is found;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> for the front-end functions that use these routines to simulate animal movement paths;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/004-model-movement.jl#L124-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.simulate_yobs-Tuple{}" href="#Patter.simulate_yobs-Tuple{}"><code>Patter.simulate_yobs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_yobs(; paths::Matrix{&lt;:State}, model_obs::Vector{ModelObs}, timeline::Vector{DateTime})</code></pre><p>For a series of simulated paths, simulate a dictionary of observations. </p><p><strong>Arguments</strong></p><ul><li><code>paths</code>: A <code>Matrix</code> of simulated paths from <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>;</li><li><code>model_obs</code>: A Vector of <a href="#Patter.ModelObs"><code>ModelObs</code></a> instances;</li><li><code>timeline</code>: A <code>Vector{DateTime}</code> of ordered, regularly spaced time stamps that defines the time steps for the simulation;</li></ul><p><strong>Details</strong></p><p>The function expects a <code>Matrix</code> of simulated paths (see <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>). For each simulated path, the function iterates over each step in <code>timeline</code> and simulates observations using the <code>Vector</code> of observation models. Observations are simulated by the internal generic <code>Patter.simulate_obs()</code> via <code>simulate_obs(State, model, t)</code>, where <code>t</code> is the time step. Methods are provided for the built-in <a href="#Patter.State"><code>State</code></a>s and <a href="#Patter.ModelObs"><code>ModelObs</code></a> sub-types. For custom sub-types, a corresponding <code>Patter.simulate_obs()</code> method is required. Simulated observations can be used in the particle filter to reconstruct the underlying movements (see <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>).</p><p><strong>Returns</strong></p><ul><li>A <code>Dict</code>, with one entry for each path:<ul><li>Each entry is a <code>Dict</code>, with one entry for each time stamp;<ul><li>Each time stamp entry is a <code>Vector</code> of <code>Tuple</code>s, each comprising the simulated observation and the associated <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance (see also <a href="#Patter.assemble_yobs-Tuple{}"><code>assemble_yobs()</code></a>);</li></ul></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="#Patter.State"><code>State</code></a> and <a href="#Patter.ModelMove"><code>ModelMove</code></a> for <a href="#Patter.State"><code>State</code></a> and movement model sub-types;</li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> and <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a> to simulate new <a href="#Patter.State"><code>State</code></a>s;</li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> to simulate animal movement paths (via <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> to simulate observations arising from simulated movements (via <a href="#Patter.ModelObs"><code>ModelObs</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/007-data-simulation.jl#L52-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelMove" href="#Patter.ModelMove"><code>Patter.ModelMove</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Movement models</code></pre><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> is an Abstract Type that groups movement models. </p><p><strong>Built-in sub-types</strong></p><p><a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types define the components of different kinds of movement model. The following sub-types are built-in:</p><ul><li><p>Random walks (RWs):       - <code>ModelMoveXY(map, mobility, dbn_length, dbn_heading)</code>: A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (<code>dbn_length</code>) and headings (<code>dbn_heading</code>);       -  <code>ModelMoveXYZ(map, mobility, dbn_length, dbn_heading, dbn_z)</code>: A subtype for a RW in X, Y and Z, based on distributions for step lengths (<code>dbn_length</code>), headings (<code>dbn_heading</code>) and depth (<code>dbn_z</code>);</p></li><li><p>Correlated random walks (CRWs):       -   <code>ModelMoveCXY(map, mobility, dbn_length, dbn_heading_delta)</code>: A sub-type for a CRW in X and Y, based on distributions for step lengths (<code>dbn_length</code>) and turning angles (<code>dbn_heading_delta</code>) ;       -   <code>ModelMoveCXYZ(map, mobility, dbn_length, dbn_heading_delta, dbn_z_delta)</code>: A sub-type for a CRW in X, Y and Z, based on distributions for step lengths (<code>dbn_length</code>), turning angles (<code>dbn_heading_delta</code>) and changes in depth (<code>dbn_z_delta</code>);</p></li></ul><p>These contain the following fields: </p><ul><li><code>map</code>: A field that defines the arena within which movement occurs. The coordinate reference system of the <code>map</code> must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. <code>map</code> is required by all movement models;</li><li><code>mobility</code>: A number that defines the maximum movement distance between two time steps;</li><li><code>dbn_length</code>: The distribution of step lengths;</li><li><code>dbn_heading</code>: The distribution of headings;</li><li><code>dbn_heading_delta</code>: The distribution of turning angles;</li><li><code>dbn_z</code>: The distribution of depths;</li><li><code>dbn_z_delta</code>: The distribution of changes in depth;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelMoveXYZ</code>*, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelMove</code>:</p><pre><code class="nohighlight hljs">struct ModelMoveXYZ{T, U, V, W, X} &lt;: Patter.ModelMove
    # The environment (i.e., map)
    # &gt; This defines the regions within which movements are permitted (i.e., in water)
    map::T
    # Distribution for step lengths
    mobility::U
    dbn_length::V
    # Distribution for headings
    dbn_heading::W
    # Distribution for changes in depth
    dbn_z::X
  end</code></pre><ul><li>Note this structure is now implemented. </li></ul><p>New <a href="#Patter.ModelMove"><code>ModelMove</code></a> structures should obey the following requirements:</p><ul><li>The <code>map</code> and <code>mobility</code> fields are required by all <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-types; </li><li>By default, <code>map</code> is assumed to be a <code>GeoArray</code> but a shapefile can be used with a custom <a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>extract()</code></a> method;</li></ul><p>To use a new <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.State"><code>State</code></a> sub-type;</li><li>(optional) Define <code>Patter.map_init()</code> and <code>Patter.states_init()</code> methods for <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/004-model-movement.jl#L8-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.ModelObs" href="#Patter.ModelObs"><code>Patter.ModelObs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Observation models</code></pre><p><strong><code>ModelObs</code></strong></p><p><code>ModelObs</code> is an Abstract Type that groups observation model structures. See below for built-in sub-types. </p><p><strong>Built-in sub-types</strong></p><p><strong><code>ModelObsAcousticLogisTrunc</code></strong></p><p><code>ModelObsAcousticLogisTrunc</code> is a <code>ModelObs</code> structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (receiver) ID;</li><li><code>receiver_x</code>, <code>receiver_y</code>: Floats that define the x and y coordinates of the receiver;</li><li><code>receiver_alpha</code>, <code>receiver_beta</code>, <code>receiver_gamma</code>: Floats that define the parameters of a truncated logistic detection probability model. </li></ul><p>An acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) at receiver <span>$k$</span> (location <span>$\textit{\textbf{r}}_k = (\text{receiver\_x}, \text{receiver\_y})$</span>) at time <span>$t$</span> is modelled using a Bernoulli probability mass function:</p><p class="math-container">\[f(y^{(A)}_{t, k} | \textit{\textbf{s}}_t) = \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>where <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> is the probability of a detection at receiver <span>$k$</span> at time <span>$t$</span> given a transmission from location <span>$\textit{\textbf{s}}_t = (x, y)$</span>. <code>ModelObsAcousticLogisTrunc</code> represents <span>$p_{k,t}(\textit{\textbf{s}}_t)$</span> as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:</p><p class="math-container">\[p_{k,t}(\textit{\textbf{s}}_t) = \left\{
\begin{array}{ll}
(1 + e^{-(\text{receiver\_alpha} - \text{receiver\_beta} \cdot |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k|)})^{-1} &amp; \text{if } |\textit{\textbf{s}}_t - \textit{\textbf{r}}_k| &lt; \text{receiver\_gamma} \\
0 &amp; \text{otherwise}
\end{array}
\right.\]</p><p>where <span>$\text{receiver\_gamma}$</span> is the detection range. </p><p>To simulate an acoustic observation (<span>$y^{(A)}_{t, k} \in {0, 1}$</span>) from this model, we can draw a sample from a Bernoulli distribution:</p><p class="math-container">\[y^{(A)}_{t, k} | \textit{\textbf{s}}_t \sim \text{Bernoulli}(p_{k,t}(\textit{\textbf{s}}_t))\]</p><p>via <code>Patter.simulate_obs()</code>.</p><p><strong><code>ModelObsDepthUniformSeabed</code></strong></p><p><code>ModelObsDepthUniformSeabed</code> is <code>ModelObs</code> structure for a depth observation and a uniform depth model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_shallow_eps</code>: A float that defines the shallow depth error;</li><li><code>depth_deep_eps</code>: A float that defines the deep depth error;</li></ul><p>This model assumes that an individual must be located in an envelope around the seabed, defined by two error terms (<code>depth_shallow_eps</code> and <code>depth_deep_eps</code>), according to the equation:</p><p class="math-container">\[f\left( y_t^{(D)} |  \textit{\textbf{s}}_t \right) =
\begin{cases} 
z_t &amp; \text{if } b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps} \leq y_t^{(D)} \leq b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps} \\
0 &amp; \text{otherwise}
\end{cases}\]</p><p>where <span>$y_t^{(D)}$</span> is the observed depth, <span>$b(\textit{\textbf{s}}_t)$</span> is the bathymetric depth in location <span>$\textit{\textbf{s}}_t$</span> and <span>$z_t$</span> is a constant. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are zero, the individual&#39;s depth is required to match the bathymetric depth.</p><p>We can simulate observations from this model as follows:</p><p class="math-container">\[y_t^{(D)} |  \textit{\textbf{s}}_t \sim \text{Uniform}(b(\textit{\textbf{s}}_t) + \text{depth\_deep\_eps}, \text{min}(b(\textit{\textbf{s}}_t) - \text{depth\_shallow\_eps}, 0))\]</p><p>via <code>Patter.simulate_obs()</code>. If <code>depth_shallow_eps</code> and <code>depth_deep_eps</code> are set to zero, the <code>Patter.simulate_obs()</code> method simply returns the bathymetric depth (<code>state.map_value</code>).</p><p><strong><code>ModelObsDepthNormalTruncSeabed</code></strong></p><p><code>ModelObsDepthNormalTruncSeabed</code> is a <code>ModelObs</code> structure for a depth observation and a truncated normal model. This contains the following fields:</p><ul><li><code>sensor_id</code>: An integer that defines the sensor (tag) ID;</li><li><code>depth_sigma</code>: A float that defines the standard deviation of the normal distribution;</li><li><code>depth_deep_eps</code>: A float that defines the deep truncation parameter;</li></ul><p>This model assumes that an individual must be located in an envelope around the seabed, defined by a normal distribution centred at this location with standard deviation <code>depth_sigma</code>: </p><p class="math-container">\[f(y_t^{(D)} | \textit{\textbf{s}}_t) = \text{TruncatedNormal}(b(\textit{\textbf{s}}_t), \text{depth\_sigma}^2, 0, b(\textit{\textbf{s}}_t)).\]</p><p>We can simulate observations from this model as for previous models via <code>Patter.simulate_obs()</code>.</p><p><strong><code>ModelObsContainer</code></strong></p><p><code>ModelObsContainer</code> is a <code>ModelObs</code> structure for a container. Containers are a computational device used to mitigate particle degeneracy in the particle filter. Containers define the maximum possible distance of an individual from a location (e.g., receiver) that recorded a future observation. Accordingly, the <code>ModelObsContainer</code> structure contains the following fields:</p><ul><li><code>sensor_id</code>: An <code>integer</code> that defines the sensor ID (e.g., the receiver ID for the receiver that recorded the next detection);</li><li><code>centroid_x</code>, <code>centroid_y</code>: <code>Float</code>s that define the x and y coordinates of the container&#39;s centroid;</li><li><code>radius</code>: A <code>Float</code> that defines the radius of the container; </li></ul><p>An acoustic container defines the region within which an individual must be located according to the receiver(s) at which it was next detected. In the particle filter, particles are permitted or killed depending on whether or not they are compatible with this constraint.</p><p>We formalise the acoustic container constraint as follows. Let <span>$t$</span> denote the movement timeline (where <span>$t \in \{1,2, \dots ,T\}$</span>), <span>$\boldsymbol{s}$</span> denote the individual&#39;s latent state (typically (x,y) location), <span>$\boldsymbol{y}$</span> denote acoustic observations (detections, non-detections) at receivers and <span>$\boldsymbol{\theta}$</span> denote static parameters (in the movement and observation models). The likelihood of the observations <span>$\boldsymbol{y}_{1:T}$</span> given the parameters <span>$\boldsymbol{\theta}$</span> is expressed as</p><p class="math-container">\[f(\boldsymbol{y}_{1:T}\mid\boldsymbol{\theta}) =
\int
\prod_{t=1}^{T}
f(\boldsymbol{y}_{t}\mid\boldsymbol{s}_{t},\boldsymbol{\theta})
\, f(\boldsymbol{s}_{t}\mid\boldsymbol{s}_{t-1},\boldsymbol{\theta})
\, d\boldsymbol{s}_{1:T}.\]</p><p>Acoustic containerisation represents a redefinition of the likelihood <span>$f(\boldsymbol{y}_{t}\mid\boldsymbol{s}_{t},\boldsymbol{\theta})$</span>, in a manner that does not affect the likelihood <span>$f(\boldsymbol{y}_{1:T}\mid\boldsymbol{\theta})$</span>, with the addition of a characteristic function <span>$\chi(t,\boldsymbol{s}_{t},\boldsymbol{y}) \in \{0,1\}$</span> that returns zero or one depending on whether or not the latent state <span>$\boldsymbol{s}_{t}$</span> is compatible with the observations at some future time:</p><p class="math-container">\[f(\boldsymbol{y}_{1:T}\mid\boldsymbol{\theta}) =
\int
\prod_{t=1}^{T}
f(\boldsymbol{y}_{t}\mid\boldsymbol{s}_{t},\boldsymbol{\theta})
\, \chi(t,\boldsymbol{s}_{t},\boldsymbol{y})
\, f(\boldsymbol{s}_{t}\mid\boldsymbol{s}_{t-1},\boldsymbol{\theta})
\, d\boldsymbol{s}_{1:T}.\]</p><p>The characteristic function <span>$\chi(t,\boldsymbol{s}_{t},\boldsymbol{y})$</span> is defined as follows.   Let <span>$\Delta(t)$</span> be a function that identifies the next time step (at some time after <span>$t$</span>) at which detection(s) were recorded.   At time <span>$t$</span> the individual must be within a maximum distance (denoted <span>$\text{radius}_{k}$</span>) of each receiver <span>$k$</span> that recorded the next detection(s):</p><p class="math-container">\[\chi(t,\boldsymbol{s}_{t},\boldsymbol{y}) =
\prod_{k}
\chi_{k}\!\bigl(
\lVert \boldsymbol{r}_{k,\Delta(t)} - \boldsymbol{s}_{t} \rVert
\le \text{radius}_{k}(\text{mobility})
\bigr),\]</p><p>where <span>$\boldsymbol{r}_{k,\Delta(t)}$</span> denotes the location of receiver <span>$k$</span>.</p><p>The radius for receiver <span>$k$</span> at time <span>$t$</span> depends on the number of time steps from <span>$t$</span> until the detection event <span>$(\Delta(t)-t)$</span>, a parameter <span>$\text{mobility} \in \boldsymbol{\theta}$</span> that defines the maximum possible moveable distance in between two time steps (i.e., from <span>$t \to t+1$</span>) and the receiver’s maximum detection range <span>$\gamma \in \boldsymbol{\theta}$</span>:</p><p class="math-container">\[\text{radius}(\text{mobility}) =
(\Delta(t)-t)\,\text{mobility} + \gamma.\]</p><p>In practice, acoustic containers are implemented via the <code>ModelObsContainer</code> structure (that is, we treat the container like an additional observation, even though it is simply a redundant use of the data).  <code>ModelObsContainer</code> instances must be assembled before the filter run, following the equations above. For relevant time steps, it is necessary to build a <code>ModelObsContainer</code> for each of the receiver(s) that recorded a detection at the next detection time step. Each instance contains <code>centroid_x</code> and <code>centroid_y</code> elements that define the centroid of the container and a <code>radius</code> element that defines the maximum possible distance of the individual from the container centroid (see above).</p><p>In the particle filter, at each time <span>$t$</span>, we iterate over all observation‑model structures and update particle weights using a <code>Patter.logpdf_obs</code> method. For <code>ModelObsContainer</code> instances, the <code>Patter.logpdf_obs</code> method computes the distance between the particle <span>$(i)$</span> and receiver <span>$k$</span>’s location (centroid) and adds <span>$0.0$</span> or <span>$\text{-Inf}$</span> to the log weight (<span>$\text{lw}$</span>) depending on whether or not the distance is less than the radius:</p><p class="math-container">\[\text{lw}_i =
\text{lw}_i +
\log\!\bigl(
\chi_{k}\!\bigl(
\lVert \boldsymbol{r}_{k,\Delta(t)} - \boldsymbol{s}_{t} \rVert
\le \text{radius}_{k}(\text{mobility})
\bigr)
\bigr).\]</p><p>This approach is valid because we only kill particles that are incompatible with future observations. A filtering–smoothing algorithm that implements acoustic containerisation thus still approximates <span>$f(\boldsymbol{s}_{t}\mid\boldsymbol{y}_{1:T})$</span> once all data have been taken into account.</p><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>ModelObsDepthNormal</code>, simply define a <code>struct</code> that is a sub-type of <code>Patter.ModelObs</code>:</p><pre><code class="nohighlight hljs">struct ModelObsDepthNormal &lt;: Patter.ModelObs
    sensor_id::Int64
    depth_sigma::Float64
end</code></pre><p>For communication with <code>R</code>, all sub-types should include a <code>sensor_id</code> field. </p><p>Add corresponding methods to simulate observations via <code>Patter.simulate_obs()</code> and to evaluate log probabilities via <code>Patter.logpdf_obs()</code>. </p><p><strong>Simulation</strong></p><p><code>Patter.simulate_obs()</code> is an internal generic function that simulates observations, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <a href="#Patter.State"><code>State</code></a> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.simulate_obs(state::StateCXYZ, model_obs::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)
    rand(dbn)
end</code></pre><p><code>Patter.simulate_obs()</code> is wrapped by <a href="#Patter.simulate_yobs-Tuple{}"><code>simulate_yobs()</code></a> for the simulation of observations.</p><p><strong>Log probabilities</strong></p><p><code>Patter.logpdf_obs()</code> is a generic function that calculates the log probability (density) of an observation, given the animal&#39;s <a href="#Patter.State"><code>State</code></a> and a <code>ModelObs</code> instance. This accepts the following arguments:</p><ul><li><code>state</code>: A <code>State</code> instance;</li><li><code>model_obs</code>: A <a href="#Patter.ModelObs"><code>ModelObs</code></a> instance;</li><li><code>t</code>: An integer that defines the time step;</li><li><code>obs</code>: The observation;</li></ul><p>Methods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as <code>ModelObsDepthNormal</code>, as follows:</p><pre><code class="nohighlight hljs">function Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end</code></pre><p><code>Patter.logpdf_obs()</code> is used in <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> to evaluate the log-probability of the data given particle samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/005-model-observation.jl#L9-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.Particles" href="#Patter.Particles"><code>Patter.Particles</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Particles(states::Union{Nothing, Matrix{&lt;:State}}, diagnostics::DataFrame, callstats::DataFrame)</code></pre><p><strong>Fields</strong></p><ul><li><code>states</code>: (optional) A <code>Matrix</code> of <a href="#Patter.State"><code>State</code></a>s:<ul><li>Each row corresponds to a particle;</li><li>Each column corresponds to the <code>timestep</code>;</li></ul></li><li><code>diagnostics</code>: A <code>DataFrame</code> of algorithm diagnostics:<ul><li><code>timestep</code>: A <code>Vector{Int64}</code> of time steps;</li><li><code>timestamp</code>: A <code>Vector{DateTime}</code> of time stamps;</li><li><code>ess</code>: A <code>Vector{Float64}</code> that defines the effective sample size at each time step;</li><li><code>maxlp</code>:  <code>Vector{Float64}</code> that defines the maximum log weight at each time step (i.e., the maximum log-posterior, if resampling is implemented at every time step);</li></ul></li><li><code>callstats</code>: A one-row <code>DataFrame</code> of call statistics:<ul><li><code>timestamp</code>: A <code>DateTime</code> that define the start time of the function call;</li><li><code>routine</code>: A <code>String</code> that defines the algorithm;</li><li><code>n_particle</code>: An <code>Int</code> that defines the number of particles;</li><li><code>n_iter</code>: An <code>Int</code> or <code>NaN</code> that defines the number of iterations (trials);</li><li><code>convergence</code>: A <code>Boolian</code> that defines convergence;</li><li><code>loglik</code>: A <code>Float64</code> that defines the log-likelihood (log P(observations | θ));</li><li><code>time</code>: A <code>Float64</code> that defines the duration (s) of the function call;</li></ul></li></ul><p><strong>Details</strong></p><ul><li><code>states</code> is <code>nothing</code> if <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a> or <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a> are implemented with <code>batch</code>ing. </li><li><code>convergence</code> is defined as follows:<ul><li>In <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>, <code>convergence</code> defines whether or not the filter reached the end of the <code>timeline</code>;</li><li>In <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>, <code>convergence</code> defines whether or not correct smoothing was achieved on at least 95 % of time steps. &#39;Correct smoothing&#39; is possible when there at at least some valid moves between the subset of recorded particles on the backward filter and those on the forward filter (for the previous time step). </li></ul></li></ul><p><strong>See also</strong></p><p><code>Particles</code> objects are returned by:</p><ul><li><a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a></li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/009-particle-filter.jl#L11-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Patter.State" href="#Patter.State"><code>Patter.State</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p><code>State</code> is an Abstract Type that defines the animal&#39;s state at a given time step. </p><p><strong>Built-in sub-types</strong></p><p>The following sub-types are built-in:</p><ul><li><code>StateXY(map_value, x, y)</code>: Used for two dimensional (x, y) states;</li><li><code>StateXYZ(map_value, x, y, z)</code>: Used for three-dimensional (x, y, z) states;</li><li><code>StateCXY(map_value, x, y, heading)</code>: Used for two-dimensional (x, y) correlated states;</li><li><code>StateCXYZ(map_value, x, y, z, heading)</code>: Used for three-dimensional (x, y, z) correlated states;</li></ul><p>These contain the following fields: </p><ul><li><code>map_value</code>: The value of the movement map at coordinates (x, y), required for all <code>State</code>s (see <a href="#Patter.ModelMove"><code>ModelMove</code></a>);</li><li><code>x</code>, <code>y</code>:  Floats that define the animal&#39;s x and y coordinates, required for all <code>State</code>s;</li><li><code>z</code>: A float that defines the animal&#39;s z (depth) coordinate, required for all <code>State</code>s with a depth component;</li><li><code>heading</code>: A float that defines the heading, required by <code>StateCXYZ</code>;</li></ul><p><strong>Custom sub-types</strong></p><p>To define a custom sub-type, such as <code>StateXYZ</code>*, simply define a <code>struct</code> that is a sub-type of <code>Patter.State</code>:</p><pre><code class="nohighlight hljs">struct StateXYZ &lt;: Patter.State
    # Map value
    map_value::Float64
    # Coordinates
    x::Float64
    y::Float64
    z::Float64
end</code></pre><ul><li>Note that <code>StateXYZ</code> is now implemented.</li></ul><p>New states should obey the following requirements:</p><ul><li>All states must include <code>map_value</code>, <code>x</code> and <code>y</code> fields;</li><li>For states with a depth dimension, the depth field must be named <code>z</code> (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>);</li><li>For <code>R</code> users, all fields must be of type <code>Float64</code> for <code>Patter.r_get_states()</code> to parse state vectors;</li></ul><p>To use a new <code>State</code> sub-type in the simulation of animal movements (via <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a>) and particle-filtering algorithms, the following steps are also necessary:</p><ul><li>Define a corresponding <a href="#Patter.ModelMove"><code>ModelMove</code></a> sub-type;</li><li>(optional) Define <code>Patter.map_init()</code> and <code>Patter.states_init()</code> methods for <a href="#Patter.simulate_states_init"><code>simulate_states_init()</code></a> to simulate initial states;</li><li>Define a <a href="#Patter.simulate_step"><code>Patter.simulate_step()</code></a> method (for <a href="#Patter.simulate_move"><code>Patter.simulate_move()</code></a>) to update the state using a <a href="#Patter.ModelMove"><code>ModelMove</code></a> instance (in <a href="#Patter.simulate_path_walk-Tuple{}"><code>simulate_path_walk()</code></a> and <a href="#Patter.particle_filter-Tuple{}"><code>particle_filter()</code></a>);</li><li>Define a <a href="#Patter.logpdf_step"><code>Patter.logpdf_step()</code></a> method (for <a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move()</code></a>) to evaluate the probability density of movement from one state to another (in <a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>particle_smoother_two_filter()</code></a>);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwardlavender/Patter.jl/blob/e78598354a3c0250fe7fa3fbae937e568d9fa4b4/src/003-states.jl#L5-L54">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Patter.ModelMove"><code>Patter.ModelMove</code></a></li><li><a href="#Patter.ModelObs"><code>Patter.ModelObs</code></a></li><li><a href="#Patter.Particles"><code>Patter.Particles</code></a></li><li><a href="#Patter.State"><code>Patter.State</code></a></li><li><a href="#Patter.assemble_yobs-Tuple{}"><code>Patter.assemble_yobs</code></a></li><li><a href="#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}"><code>Patter.extract</code></a></li><li><a href="#Patter.is_valid"><code>Patter.is_valid</code></a></li><li><a href="#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{&lt;:State, Float64}}}"><code>Patter.logpdf_move</code></a></li><li><a href="#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}"><code>Patter.logpdf_move_normalisation</code></a></li><li><a href="#Patter.logpdf_step"><code>Patter.logpdf_step</code></a></li><li><a href="#Patter.particle_filter-Tuple{}"><code>Patter.particle_filter</code></a></li><li><a href="#Patter.particle_smoother_two_filter-Tuple{}"><code>Patter.particle_smoother_two_filter</code></a></li><li><a href="#Patter.resample"><code>Patter.resample</code></a></li><li><a href="#Patter.simulate_move"><code>Patter.simulate_move</code></a></li><li><a href="#Patter.simulate_path_walk-Tuple{}"><code>Patter.simulate_path_walk</code></a></li><li><a href="#Patter.simulate_states_init"><code>Patter.simulate_states_init</code></a></li><li><a href="#Patter.simulate_step"><code>Patter.simulate_step</code></a></li><li><a href="#Patter.simulate_yobs-Tuple{}"><code>Patter.simulate_yobs</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 18 April 2025 13:54">Friday 18 April 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
