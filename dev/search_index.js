var documenterSearchIndex = {"docs":
[{"location":"#Patter.jl","page":"Patter.jl","title":"Patter.jl","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"},{"location":"#Functions","page":"Patter.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"Modules = [Patter]\nOrder   = [:function, :type]","category":"page"},{"location":"#Patter.assemble_yobs-Tuple{}","page":"Patter.jl","title":"Patter.assemble_yobs","text":"assemble_yobs(; datasets::Vector, model_obs_types::Vector{DataType})\n\nAssemble a dictionary of observations (and associated model parameters) for the particle filter (particle_filter()). \n\nArguments (keywords)\n\ndatasets: A Vector of DataFrames, one for each data type. Each DataFrame must contain the following columns:\ntimestamp: A DateTime Vector of time stamps;\nsensor_id: A Vector of sensor IDs;\nobs: A Vector of observations;\nAdditional columns required to construct ModelObs instances (that is, model parameters);\nmodel_obs_types: A Vector of ModelObs sub-types (one for each dataset);\n\nDetails\n\nThe function iterates over animal-tracking datasets (for example, acoustic and archival [depth] time series for a particular individual) and corresponding observation model types and creates a typed dictionary of time stamps for the particle filter (see particle_filter()'s yobs argument). Each time step contains a Vector of Tuples, with one element for each sensor that recorded an observation at that time stamp. For example, each element might correspond to an acoustic receiver and/or the individual's archival tag. Each element is a Tuple that defines the observation and the corresponding observation model parameters (that is, a ModelObs instance). \n\nReturns\n\nA Dict:\nEach element corresponds to a timestamp:\nEach timestamped element contains a Vector of Tuples (one for each observation):\nEach Tuple contains an observation and the corresponding ModelObs instance;\n\nSee also\n\nassemble_yobs() to assemble real-world datasets for the particle filter;\nsimulate_yobs() to simulate observations for the particle filter;\nparticle_filter() to implement the particle filter;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}","page":"Patter.jl","title":"Patter.extract","text":"extract(map::GeoArrays.GeoArray, x::Real, y::Real)\n\nExtract the value of a GeoArray (such as a bathymetry grid) at a pair of x and y coordinates.\n\nDetails\n\nIn Patter.jl, map is a GeoArray that defines the area within which movements are possible. In our applications, map is often a bathymetry raster that defines the depth of the seabed across the study area. map is an essential field in individual movement models (see ModelMove). The internal extract() function supports the simulation of initial states (via simulate_states_init()) and the updating of states (via simulate_step()), as required to simulate animal movement paths (e.g., in simulate_path_walk() and particle_filter()). Individual states define, at a minimum, the individual's location (x, y) and the value of the map at that location (map_value), which is extracted by extract() (see State). The Coordinate Reference Systems for map, x and y must align for this to work (i.e., map should use a Universal Transverse Mercator projection with coordinates in metres). extract() is exported so that it can be used in new methods (for custom states or movement models) of these functions. The simulation of individual movements (via simulate_step()) is implemented iteratively (via simulate_move()) until a valid movement is found. NaN is taken to define inhospitable habitats, such as land, into which the individual cannot move (see is_valid()). It should be possible to use a map in another format (such as a shapefile) within these routines, with a custom extract() method that returns NaN in inhospitable habitats and a numeric constant otherwise. \n\nReturns\n\nThe value of the GeoArray for a coordinate pair within the bounds of map;\nNaN (of the same type as map's elements) for a coordinate pair beyond the bounds of map;\n\nSee also\n\nState for State sub-types;\nextract to extract values from map at State coordinates;\nsimulate_step() to simulate a new State;\nis_valid() to determine whether or not a simulated state is valid;\nsimulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.is_valid","page":"Patter.jl","title":"Patter.is_valid","text":"is_valid(map_value::Real)\nis_valid(map_value::Real, z::Real)\n\nDetermine the validity of a point on a map.\n\nFor two-dimensional (x, y) states, is_valid(map_value) checks if the map_value (at a point (x, y)) is not NaN.\n\nFor states with a depth (z) component, is_valid(map_value, z), checks that map_value is not NaN and that the provided z-coordinate (z) lies within the valid range, specifically 0 < z â‰¤ map_value (i.e., the animal is not below the seabed).\n\nArguments\n\nmap_value: The value of the map in a particular location;\nz: (optional) The z-coordinate (depth) of the animal, used for states that contain a depth component only;\n\nDetails\n\nThese are internal functions. They are used to validate simulated individual states (see State). Individual states (i.e., locations) are simulated via simulate_step(). simulate_move() wraps simulate_step(), iteratively proposing states until a valid state is found. This is required to simulate animal movement paths (e.g., in simulate_path_walk() and particle_filter()).\n\nReturns\n\ntrue if the conditions for validity are met;\nfalse otherwise;\n\nSee also\n\nState for State sub-types;\nextract to extract values from map at State coordinates;\nsimulate_step() to simulate a new State;\nis_valid() to determine whether or not a simulated state is valid;\nsimulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get","page":"Patter.jl","title":"Patter.julia_get","text":"Julia from R\n\nA collection of internal functions that facilitate the translation of objects from R into Julia objects.\n\nDetails\n\nPatter.julia_get_xinit() gets a Vector of initial States from a DataFrame;\nPatter.julia_get_model_obs_types() gets a Vector of ModelObs sub-types from a Vector of Strings;\nPatter.julia_get_model_obs() gets a Vector of ModelObs instances from a Vector of DataFrames that contain parameters and a corresponding vector of ModelObs sub-types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get_model_obs","page":"Patter.jl","title":"Patter.julia_get_model_obs","text":"Julia from R\n\nA collection of internal functions that facilitate the translation of objects from R into Julia objects.\n\nDetails\n\nPatter.julia_get_xinit() gets a Vector of initial States from a DataFrame;\nPatter.julia_get_model_obs_types() gets a Vector of ModelObs sub-types from a Vector of Strings;\nPatter.julia_get_model_obs() gets a Vector of ModelObs instances from a Vector of DataFrames that contain parameters and a corresponding vector of ModelObs sub-types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get_model_obs_types","page":"Patter.jl","title":"Patter.julia_get_model_obs_types","text":"Julia from R\n\nA collection of internal functions that facilitate the translation of objects from R into Julia objects.\n\nDetails\n\nPatter.julia_get_xinit() gets a Vector of initial States from a DataFrame;\nPatter.julia_get_model_obs_types() gets a Vector of ModelObs sub-types from a Vector of Strings;\nPatter.julia_get_model_obs() gets a Vector of ModelObs instances from a Vector of DataFrames that contain parameters and a corresponding vector of ModelObs sub-types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get_xinit","page":"Patter.jl","title":"Patter.julia_get_xinit","text":"Julia from R\n\nA collection of internal functions that facilitate the translation of objects from R into Julia objects.\n\nDetails\n\nPatter.julia_get_xinit() gets a Vector of initial States from a DataFrame;\nPatter.julia_get_model_obs_types() gets a Vector of ModelObs sub-types from a Vector of Strings;\nPatter.julia_get_model_obs() gets a Vector of ModelObs instances from a Vector of DataFrames that contain parameters and a corresponding vector of ModelObs sub-types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_move","page":"Patter.jl","title":"Patter.logpdf_move","text":"logpdf_move(state_from::State, state_to::State, state_zdim::Bool, \n            model_move::ModelMove, t::Int, box, \n            n_sim::Int,\n            cache::LRU)\n\nEvaluate the log probability of a movement step between two States (state_from and state_to). \n\nArguments\n\nstate_from: A State instance that defines a State from which the animal moved;\nstate_to: A State instance that defines a State into which the animal moved;\nstate_zdim: A Boolian that defines whether or not state_from and state_to contain a z (depth) dimension;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\nbox: (optional) A NamedTuple (min_x, max_x, min_y, max_y) that defines a 'mobility box' within which movements between state_from and state_to are always (theoretically) legal. This can be provided if state_from and state_to are StateXY instances and model_move.map does not contain NAs;\nn_sim: An integer that defines the number of Monte Carlo simulations (used to approximate the normalisation constant);\ncache: A Least Recently Used (LRU) Cache;\n\nDetails\n\nlogpdf_move() is an internal function that evaluates the log probability of a movement step between two State(s) (i.e., locations). This function wraps logpdf_step(), accounting for accounting for restrictions to movement; that is, logpdf_move() evaluates logpdf_step(state_from, state_to, model_move, length, angle) + log(abs(determinate)) - log(Z) where Z is the normalisation constant. If state_from and state_to are two-dimensional states (i.e., StateXY instances) and model_move.map does not contain NaNs, a 'mobility box' can be provided. This is a NamedTuple of coordinates that define the region within which movements between two locations are always theoretically legal. In this instance, the normalisation constant is simply log(1.0). Otherwise, a Monte Carlo simulation of n_sim iterations is required to approximate the normalisation constant, accounting for invalid movements, which is more expensive (see logpdf_move_normalisation()). logpdf_move() is used for particle smoothing (see two_filter_smoother()).\n\nReturns\n\nA number (log probability); \n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() and simulate_move() to simulate new States;\nlogpdf_step() and logpdf_move() to evaluate the log-probability of movement between two locations;\nlogpdf_move_normalisation() for estimation of the normalisation constant;\ntwo_filter_smoother() for the front-end function that uses these routines for particle smoothing;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Int64}","page":"Patter.jl","title":"Patter.logpdf_move_normalisation","text":"logpdf_move_normalisation(state::State, state_zdim::Bool, \n                          model_move::ModelMove, t::Int, n_sim::Int, \n                          cache::LRU)\n\nApproximate the normalisation constant for the (log) probability density of movement from one State (location) into another. \n\nArguments\n\nstate_from: A State instance that defines a State from which the animal moved;\nstate_zdim: A Boolian that defines whether or not state_from contains a z (depth) dimension;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\nn_sim: An integer that defines the number of Monte Carlo simulations;\ncache: A Least Recently Used (LRU) cache;\n\nDetails\n\nThis internal function runs a Monte Carlo simulation of n_sim iterations to estimate the normalisation constant for the (log) probability of movement from one State (state_from) into another. A Beta(1, 1) prior is used to correct for simulations that fail to generate valid move from state_from. The normalisation constant for a given State is stored in a LRU cache. This function is used by logpdf_move() to evaluate the (log) probability of movement between two states, which is required for particle smoothing (see two_filter_smoother()).\n\nReturns\n\nA number (the normalisation constant); \n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() and simulate_move() to simulate new States;\nlogpdf_step() and logpdf_move() to evaluate the log-probability of movement between two locations;\nlogpdf_move_normalisation() for estimation of the normalisation constant;\ntwo_filter_smoother() for the front-end function that uses these routines for particle smoothing;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.logpdf_obs","page":"Patter.jl","title":"Patter.logpdf_obs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_step","page":"Patter.jl","title":"Patter.logpdf_step","text":"logpdf_step(state_from::State, state_to::State, model_move::ModelMove, length, angle)\n\nEvaluate the (unnormalised) log probability of an (unrestricted) movement step. \n\nArguments\n\nstate_from: A State instance that defines a State from which the animal moved;\nstate_to: A State instance that defines a State into which the animal moved;\nmodel_move: A ModelMove instance;\nlength: A float that defines the step length (i.e., the Euclidean distance between state_from (x, y) and state_to (x, y));\nangle: A float that defines the angle (in polar coordinates) between state_from (x, y) and state_to (x, y);\n\nDetails\n\nlogpdf_step() is an internal generic function that evaluates the (unnormalised) log probability of an (unrestricted) movement step between two State(s) (i.e., locations). Methods are provided for the built-in State and ModelMove sub-types, but need to be provided for custom sub-types. Internally, logpdf_step() is wrapped by logpdf_move(), which evaluates the log probability of movement between two States, accounting for restrictions to movement; that is, logpdf_move() evaluates logpdf_step(state_from, state_to, model_move, length, angle) + log(abs(determinate)) - log(Z) where Z is the normalisation constant. This is required for particle smoothing (see two_filter_smoother()).\n\nReturns\n\nA number (log probability); \n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() and simulate_move() to simulate new States;\nlogpdf_step() and logpdf_move() to evaluate the log-probability of movement between two locations;\nlogpdf_move_normalisation() for estimation of the normalisation constant;\ntwo_filter_smoother() for the front-end function that uses these routines for particle smoothing;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.particle_filter-Tuple{}","page":"Patter.jl","title":"Patter.particle_filter","text":"Particle filter\n\nA particle filtering algorithm that samples from f(X_t | {Y_1 ... Y_t}) for t âˆˆ 1:t.\n\nArguments (keywords)\n\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\nxinit: A Vector of State instances that defines the initial state(s) of the animal;\nyobs: A Dictionary of observations:\nDictionary keys should match elements in timeline;\nEach element must be a Vector of Tuples for that time step (one for each observation/sensor);\nEach Tuple should contain (a) the observation and (b) the model parameters (that is, a ModelObs instance);\nmodel_move: A ModelMove instance:\nThe movement model describes movement from one time step to the next and therefore depends implicitly on the resolution of timeline;\nThe movement model should align with the State instances in xinit. For example, a two-dimensional state (StateXY) requires a corresponding movement model instance (i.e., ModelMoveXY); \nn_move: An integer that defines the number of attempts used to find a legal move; \nAll ModelMove sub-types contain a map field that defines the region(s) within which movements are allowed (see is_valid());\nEach particle is moved up to n_move times, until a valid movement is simulated;\nParticles that fail to generate a valid move are killed;\nn_record: An integer that defines the number of particles to record at each time step:\nn_record particles are resampled at each time step and recorded in memory;\nn_resample: A number that defines the effective sample size for resampling:\nParticles are resampled when the effective sample size <= n_resample;\ndirection: A String that defines the direction of the filter:\n\"forward\" runs the filter forwards in time;\n\"backward\" runs the filter backwards in time;\n\nAlgorithm\n\nInitiation\n\nThe algorithm is initiated using a Vector of n_particle States (xinit). See simulate_states_init() to simulate initial states for the filter.  \n\nMovement\n\nFor every time step in the timeline, the internal function simulate_move() simulates the movement of particles away from previous States into new States using the movement model, as specified by model_move. simulate_move() is an iterative wrapper for a simulate_step() method that simulates a new State instance from the previous State. simulate_move() implements simulate_step() iteratively until a legal move is found (or n_move is reached). For custom State or ModelObs sub-types, a corresponding simulate_step() method is required. Illegal moves are those that land in NaN locations on the map or, in the case of States that include a depth (z) component, are below the depth of the seabed (see is_valid()). Particles that fail to generate legal moves are eventually killed by re-sampling (see below).\n\nLikelihood\n\nObservations are used to weight simulated particles. To simulate observations for filtering, use simulate_yobs(). To assemble real-world observations for filtering, see assemble_yobs(). For each valid State and time stamp in yobs, the log-probability of each observation, given the State, is evaluated via logpdf_obs(). For custom State or ModelObs sub-types, a corresponding logpdf_obs() method is required. The maximum log-probability across all particles is recorded at each time step as an algorithm diagnostic.\n\nResampling\n\nParticles are periodically re-sampled, with replacement, using the low-variance systematic re-sampling algorithm (via resample()), when the effective sample size is less than or equal to n_resample. This has the effect of eliminating impossible particles and duplicating likely ones.\n\nThe algorithm continues in this way, iterating over the timeline, simulating, weighting and (re)sampling particles. At each time step, n_record particles are saved in memory. If the function fails to converge, a warning is returned alongside the outputs up to that time step. Otherwise, the function will continue to the end of the time series.\n\nMulti-threading\n\nThe iteration over particles (i.e., simulated movements and likelihood evaluations) are multi-threaded. \n\nConvergence and diagnostics\n\nAlgorithm convergence is not guaranteed. The algorithm may reach a dead-endâ€“-a time step at which there are no valid locations into which the algorithm can step. This may be due to data errors, incorrect assumptions, insufficient sampling effort or poor tuning-parameter settings.\n\nReturns\n\nA NamedTuple with the following fields:\ntimesteps: An Vector{Int64} of time steps;\ntimestamps: The timeline;\ndirection: The direction;\nstate: A Matrix of States:\nEach row corresponds to a particle; \nEach column corresponds to the timestep;\ness: A Vector{Float64} that defines the effective sample size at each time step;\nmaxlp: A Vector{Float64} that defines the maximum log-posterior at each time step;\nconvergence: A Boolian that defines whether or not the algorithm reached the end of the timeline;\n\nSee also\n\nState, ModelMove and ModelObs for State, movement model and observation model sub-types;\nsimulate_yobs() and assemble_yobs() to prepare observations for the particle filter;\nsimulate_step() and simulate_move() for the internal routines used to simulate new States;\nlogpdf_obs() methods to evaluate the log probability of observations;\ntwo_filter_smoother() to implement particle smoothing;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.r_get","page":"Patter.jl","title":"Patter.r_get","text":"R from Julia\n\nA collection of internal functions that facilitate the translation of Julia objects into R. \n\nDetails\n\nPatter.r_get_dataset() translates a Dictionary of observations into a Vector of DataFrames that can be passed to R.\nPatter.r_get_states() translates a Matrix of States into a DataFrame that can be passed to R. In the input Matrix, each row is a particle and each column is a time step. \nPatter.r_get_particles() wraps Patter.r_get_states() and translates particle outputs (from particle_filter() and two_filter_smoother()) into a NamedTuple for R.\n\nThese functions are State and model agnostic; that is, they work irrespective of the input State and model sub-types. Custom methods are not required to handle novel sub-types. \n\nReturns\n\nPatter.r_get_dataset() returns a Vector of DataFrames, with columns for timestamp, obs and the observation model parameters;\nPatter.r_get_states() returns a long-format DataFrame, with columns for path_id, timestep and each state dimension;\nPatter.r_get_particles() returns a NamedTuple of particle information, including:\nstates: A DataFrame of State dimensions (from Patter.r_get_states());\ndiagnostics: A DataFrame of algorithm diagnostics, including timestep, timestamp, ess and maxlp columns;\nconvergence: A Boolian that defines algorithm convergence;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.r_get_dataset","page":"Patter.jl","title":"Patter.r_get_dataset","text":"R from Julia\n\nA collection of internal functions that facilitate the translation of Julia objects into R. \n\nDetails\n\nPatter.r_get_dataset() translates a Dictionary of observations into a Vector of DataFrames that can be passed to R.\nPatter.r_get_states() translates a Matrix of States into a DataFrame that can be passed to R. In the input Matrix, each row is a particle and each column is a time step. \nPatter.r_get_particles() wraps Patter.r_get_states() and translates particle outputs (from particle_filter() and two_filter_smoother()) into a NamedTuple for R.\n\nThese functions are State and model agnostic; that is, they work irrespective of the input State and model sub-types. Custom methods are not required to handle novel sub-types. \n\nReturns\n\nPatter.r_get_dataset() returns a Vector of DataFrames, with columns for timestamp, obs and the observation model parameters;\nPatter.r_get_states() returns a long-format DataFrame, with columns for path_id, timestep and each state dimension;\nPatter.r_get_particles() returns a NamedTuple of particle information, including:\nstates: A DataFrame of State dimensions (from Patter.r_get_states());\ndiagnostics: A DataFrame of algorithm diagnostics, including timestep, timestamp, ess and maxlp columns;\nconvergence: A Boolian that defines algorithm convergence;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.r_get_particles","page":"Patter.jl","title":"Patter.r_get_particles","text":"R from Julia\n\nA collection of internal functions that facilitate the translation of Julia objects into R. \n\nDetails\n\nPatter.r_get_dataset() translates a Dictionary of observations into a Vector of DataFrames that can be passed to R.\nPatter.r_get_states() translates a Matrix of States into a DataFrame that can be passed to R. In the input Matrix, each row is a particle and each column is a time step. \nPatter.r_get_particles() wraps Patter.r_get_states() and translates particle outputs (from particle_filter() and two_filter_smoother()) into a NamedTuple for R.\n\nThese functions are State and model agnostic; that is, they work irrespective of the input State and model sub-types. Custom methods are not required to handle novel sub-types. \n\nReturns\n\nPatter.r_get_dataset() returns a Vector of DataFrames, with columns for timestamp, obs and the observation model parameters;\nPatter.r_get_states() returns a long-format DataFrame, with columns for path_id, timestep and each state dimension;\nPatter.r_get_particles() returns a NamedTuple of particle information, including:\nstates: A DataFrame of State dimensions (from Patter.r_get_states());\ndiagnostics: A DataFrame of algorithm diagnostics, including timestep, timestamp, ess and maxlp columns;\nconvergence: A Boolian that defines algorithm convergence;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.r_get_states","page":"Patter.jl","title":"Patter.r_get_states","text":"R from Julia\n\nA collection of internal functions that facilitate the translation of Julia objects into R. \n\nDetails\n\nPatter.r_get_dataset() translates a Dictionary of observations into a Vector of DataFrames that can be passed to R.\nPatter.r_get_states() translates a Matrix of States into a DataFrame that can be passed to R. In the input Matrix, each row is a particle and each column is a time step. \nPatter.r_get_particles() wraps Patter.r_get_states() and translates particle outputs (from particle_filter() and two_filter_smoother()) into a NamedTuple for R.\n\nThese functions are State and model agnostic; that is, they work irrespective of the input State and model sub-types. Custom methods are not required to handle novel sub-types. \n\nReturns\n\nPatter.r_get_dataset() returns a Vector of DataFrames, with columns for timestamp, obs and the observation model parameters;\nPatter.r_get_states() returns a long-format DataFrame, with columns for path_id, timestep and each state dimension;\nPatter.r_get_particles() returns a NamedTuple of particle information, including:\nstates: A DataFrame of State dimensions (from Patter.r_get_states());\ndiagnostics: A DataFrame of algorithm diagnostics, including timestep, timestamp, ess and maxlp columns;\nconvergence: A Boolian that defines algorithm convergence;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.resample","page":"Patter.jl","title":"Patter.resample","text":"resample(w::Vector{Float64}, n::Int)\n\nGiven a weight vector w, resample a set of indices based on low-variance resampling algorithm from Thrun, Burgard and Fox's \"Probabilistic Robotics\".\n\nArguments\n\nw: A Vector{Float64} of weights;\nn: An integer that defines the number of particles;\n\nDetails\n\nThis is an internal function that implements systematic resampling in the particle filter (see particle_filter()) and smoothing algorithms (see two_filter_smoother()). Note that for large n, the function is not numerically stable. \n\nReturns\n\nAn integer vector of indices;\n\nExample\n\nX = [\"A\", \"B\", \"C\", \"D\"]\nw = [0, 0, 0.75, 0.25]\n\nidx = resample(w, 12)\nX[idx]\n\nSource\n\nCode adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_move","page":"Patter.jl","title":"Patter.simulate_move","text":"simulate_move(state::State, model::ModelMove, t::Int64, n_trial::Real)\n\nSimulate movement from one location (State) into a new location (State).\n\nArguments\n\nstate: A State instance that defines the animal's previous State;\nmodel: A ModelMove instance;\nt: An integer that defines the time step;\nn_trial: A number that defines the number of attempts to simulate a valid State;\n\nDetails\n\nsimulate_move() is an internal function that uses a simulate_step() method to simulate new state proposals iteratively until a valid State is generated or n_trial is reached (see is_valid()). For custom States or ModelMove sub-types, corresponding simulate_step() methods must be provided for this function. simulate_move() is used to simulate movement paths (e.g., in simulate_path_walk() and particle_filter()).\n\nReturns\n\nA Tuple that comprises the simulated State instance and the (log) weight; i.e., \n([State], 0.0) if State is valid;\n([State], -Inf) if State is invalid;\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() to simulate a new State;\nis_valid() to determine whether or not a simulated state is valid;\nsimulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_obs","page":"Patter.jl","title":"Patter.simulate_obs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_path_walk-Tuple{}","page":"Patter.jl","title":"Patter.simulate_path_walk","text":"simulate_path_walk(; xinit = Vector, model_move::ModelMove, timeline::Vector{DateTime})\n\nSimulate discrete-time movement path(s) from a Vector of initial States and a random-walk movement model. \n\nArguments (keywords)\n\nxinit: A Vector of initial States instances;\nmodel_move: A ModelMove instance;\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\n\nDetails\n\nState refers to the (x, y) location of an animal (alongside additional state components, if applicable). To simulate initial states, use simulate_states_init(). For each initial state, simulate_path_walk() simulates a sequence of States (i.e., a movement path) of length(timeline) steps using the movement model (model_move). The simulation of movement from one State into another is implemented by the internal function simulate_move(), which in turn wraps simulate_step(). At each time step, simulate_move() implements simulate_step() iteratively until a valid movement is identified (see is_valid()). simulate_step() is a generic function. Methods are implemented for the built-in State and ModelMove sub-types but custom sub-types require a corresponding simulate_step() method. \n\nReturns\n\nA matrix of States:\nEach row represents a simulated path;\nEach column represents a time step along timeline;\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() and simulate_move() to simulate new States;\nsimulate_path_walk() to simulate animal movement paths (via ModelMove);\nsimulate_yobs() to simulate observations arising from simulated movements (via ModelObs);\n\n\n\n\n\n","category":"method"},{"location":"#Patter.simulate_state_init","page":"Patter.jl","title":"Patter.simulate_state_init","text":"simulate_state_init(state_type::Type{<:State}, model::ModelMove, xlim, ylim)\n\nSimulate a (tentative) initial State for an animal.\n\nArguments:\n\nstate_type: An empty State sub-type, such as StateXY, used for method dispatch only;\nmodel: A ModelMove instance;\nxlim, ylim: Pairs of numbers that define the boundaries of the area within which initial (x, y) coordinates are sampled;\n\nDetails\n\nAn initial State defines the initial (x, y) location of an animal, plus initial values for any other State components (such as the animal's initial bearing, for StateXYZD). The purpose of simulate_state_init() is to simulate an initial instance of a State. This is wrapped by the exported function simulate_states_init(), which simulates a Vector of initial States iteratively until n valid States are simulated (see is_valid()). Initial States are required to initialise the simulation of individual movement paths (e.g., in simulate_path_walk() and particle_filter()). \n\nsimulate_state_init() is an internal generic function, with methods for the built-in State sub-types. For custom State sub-types, write a corresponding simulate_state_init() function to use the exported simulate_states_init() function. \n\nReturns\n\nA State instance;\n\nSee also\n\nState for State sub-types;\nextract to extract values from map at State coordinates;\nis_valid() to determine whether or not a simulated state is valid;\nsimulate_state_init() to simulate an initial State;\nsimulate_states_init() to simulate a Vector of initial States, iteratively until n valid States are simulated;\nsimulate_path_walk() and particle_filter() for the front-end functions that use initial States to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_states_init-Tuple{}","page":"Patter.jl","title":"Patter.simulate_states_init","text":"simulate_states_init(; state_type::Type{<:State}, model::ModelMove, n::Int, xlim, ylim)\n\nSimulate a Vector of initial States for the simulation of movement paths.\n\nArguments (keywords)\n\nstate_type: An empty State sub-type, such as StateXY, used for method dispatch only;\nmodel_move: A ModelMove instance;\nn: An integer that defines number of initial states to simulate;\nxlim, ylim: (optional) Pairs of numbers that define the boundaries of the area within initial (x, y) coordinates are sampled;\n\nDetails\n\nAn initial State defines the initial (x, y) location of an animal, plus initial values for any other State components (such as the animal's initial bearing, for StateXYZD). The purpose of simulate_states_init() is to simulate a Vector of initial State instances. This wraps the internal generic function simulate_state_init(), iteratively simulating initial States until n valid States are simulated (see is_valid()). For custom State sub-types, a corresponding simulate_state_init() method is required to use this function. Initial States are required to initialise the simulation of individual movement paths (e.g., in simulate_path_walk() and particle_filter()). \n\nReturns\n\nA Vector of n State instances;\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nextract to extract values from map at State coordinates;\nis_valid() to determine whether or not a simulated state is valid;\nsimulate_state_init() to simulate an initial State;\nsimulate_states_init() to simulate a Vector of initial States, iteratively until n valid States are simulated;\nsimulate_path_walk() and particle_filter() for the front-end functions that use initial States to simulate animal movement paths;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.simulate_step","page":"Patter.jl","title":"Patter.simulate_step","text":"simulate_step(state::State, model::ModelMove, t::Int64)\n\nSimulate a (tentative) step from one location (State) into a new location (State).\n\nArguments\n\nstate: A State instance that defines the animal's previous State;\nmodel: A ModelMove instance;\nt: An integer that defines the time step;\n\nDetails\n\nsimulate_step() is an internal generic function that simulates a new value for the animal's [State], that is, the animal's location (and other state components). Methods are provided for the built-in [State] and movement model (ModelMove) sub-types. For custom States or ModelMove sub-types, corresponding methods must be provided. Internally, simulate_step() is wrapped by simulate_move(), which implements simulate_step() iteratively until a valid State is simulated (see is_valid()). \n\nReturns\n\nA State instance;\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() to simulate a new State;\nis_valid() to determine whether or not a simulated state is valid;\nsimulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_yobs-Tuple{}","page":"Patter.jl","title":"Patter.simulate_yobs","text":"simulate_yobs(; paths::Matrix, model_obs::Vector{ModelObs}, timeline::Vector{DateTime})\n\nFor a series of simulated paths, simulate a dictionary of observations. \n\nArguments\n\npaths: A Matrix of simulated paths from simulate_path_walk();\nmodel_obs: A Vector of ModelObs instances;\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\n\nDetails\n\nThe function expects a Matrix of simulated paths (see simulate_path_walk()). For each simulated path, the function iterates over each step in timeline and simulates observations using the Vector of observation models. Observations are simulated by the internal generic simulate_obs() via simulate_obs(State, model, t), where t is the time step. Methods are provided for the built-in States and ModelObs sub-types. For custom sub-types, a corresponding simulate_obs() method is required. Simulated observations can be used in the particle filter to reconstruct the underlying movements (see particle_filter()).\n\nReturns\n\nA Dict, with one entry for each path:\nEach entry is a Dict, with one entry for each time stamp;\nEach time stamp entry is a Vector of Tuples, each comprising the simulated observation and the associated ModelObs instance (see also assemble_yobs());\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nsimulate_step() and simulate_move() to simulate new States;\nsimulate_path_walk() to simulate animal movement paths (via ModelMove);\nsimulate_yobs() to simulate observations arising from simulated movements (via ModelObs);\n\n\n\n\n\n","category":"method"},{"location":"#Patter.two_filter_smoother-Tuple{}","page":"Patter.jl","title":"Patter.two_filter_smoother","text":"two_filter_smoother(; timeline::Vector{DateTime}, xfwd::Matrix, xbwd::Matrix, model_move::ModelMove, box, n_sim::Int)\n\nA two-filter particle smoother that samples from f(X_t | {Y_1 ... Y_T}) for t âˆˆ 1:T.\n\nArguments (keywords)\n\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\nxfwd: A Matrix of States from the forward filter (see particle_filter());\nxbwd: A Matrix of States from the backward filter (see particle_filter());\nmodel_move: A ModelMove instance;\nbox: (optional) A NamedTuple (min_x, max_x, min_y, max_y) that defines a 'mobility box' (see logpdf_move());\nn_sim: An integer that defines the number of Monte Carlo simulations (see logpdf_move());\n\nDetails\n\ntwo_filter_smoother() smooths particles from the particle filter (see particle_filter()). The timeline from the particle filter should be supplied as well as a Matrix of particles from a forward run and a backward run. The two filter smoother works by iteratively resampling particles in line with the probability density of movement between particles from the backward filter at time t and particles from the forward filter at time t - 1. logpdf_move() is an internal function that evaluates the log probability of a movement step between particles. This function wraps the logpdf_step() generic. Methods are provided for built-in State and ModelMove sub-types. To use custom sub-types, a corresponding logpdf_step() method should be provided. In two_filter_smoother(), the box and n_sim arguments support the calculate of probability densities (see logpdf_move()). \n\nReturns\n\nA NamedTuple, of the same format as returned by particle_filter(), with the following fields:\ntimesteps\ntimestamps\ndirection: nothing\nstate\ness\nmaxlp: NaN\nconvergence: true\n\nSee also\n\nparticle_filter() implements the particle filter;\nlogpdf_step(), logpdf_move_normalisation() and logpdf_move() evaluate the log probability (density) of movement between two States;\ntwo_filter_smoother() implements the two-filter particle smoother;\n\nSource\n\nFearnhead, P., Wyncoll, D., Tawn, J., 2010. A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447â€“464.\n\n\n\n\n\n","category":"method"},{"location":"#Patter.ModelMove","page":"Patter.jl","title":"Patter.ModelMove","text":"Movement models\n\nModelMove is an Abstract Type that groups movement models. \n\nBuilt-in sub-types\n\nModelMove sub-types define the components of different kinds of movement model. The following sub-types are built-in:\n\nModelMoveXY(map, dbn_length, dbn_angle): A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and turning angles (dbn_angle);\nModelMoveXYZD(map, dbn_length, dbn_angle_delta, dbn_z_delta): A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nThese contain the following fields: \n\nmap: A field that defines the arena within which movement occurs. The coordinate reference system of the map must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. map is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelMoveXYZ, simply define a struct that is a sub-type of Patter.ModelMove:\n\nstruct ModelMoveXYZ{T, U, V, W} <: Patter.ModelMove\n    # The environment (i.e., map)\n    # > This defines the regions within which movements are permitted (i.e., in water)\n    map::T\n    # Distribution for step lengths\n    dbn_length::U\n    # Distribution for turning angles\n    dbn_angle::V\n    # Distribution for changes in depth\n    dbn_z_delta::W\n  end\n\nNew ModelMove structures should obey the following requirements:\n\nThe map field is required by all ModelMove sub-types; \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\n\nTo use a new ModelMove sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding State sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelMoveXY","page":"Patter.jl","title":"Patter.ModelMoveXY","text":"Movement models\n\nModelMove is an Abstract Type that groups movement models. \n\nBuilt-in sub-types\n\nModelMove sub-types define the components of different kinds of movement model. The following sub-types are built-in:\n\nModelMoveXY(map, dbn_length, dbn_angle): A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and turning angles (dbn_angle);\nModelMoveXYZD(map, dbn_length, dbn_angle_delta, dbn_z_delta): A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nThese contain the following fields: \n\nmap: A field that defines the arena within which movement occurs. The coordinate reference system of the map must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. map is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelMoveXYZ, simply define a struct that is a sub-type of Patter.ModelMove:\n\nstruct ModelMoveXYZ{T, U, V, W} <: Patter.ModelMove\n    # The environment (i.e., map)\n    # > This defines the regions within which movements are permitted (i.e., in water)\n    map::T\n    # Distribution for step lengths\n    dbn_length::U\n    # Distribution for turning angles\n    dbn_angle::V\n    # Distribution for changes in depth\n    dbn_z_delta::W\n  end\n\nNew ModelMove structures should obey the following requirements:\n\nThe map field is required by all ModelMove sub-types; \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\n\nTo use a new ModelMove sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding State sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelMoveXYZD","page":"Patter.jl","title":"Patter.ModelMoveXYZD","text":"Movement models\n\nModelMove is an Abstract Type that groups movement models. \n\nBuilt-in sub-types\n\nModelMove sub-types define the components of different kinds of movement model. The following sub-types are built-in:\n\nModelMoveXY(map, dbn_length, dbn_angle): A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and turning angles (dbn_angle);\nModelMoveXYZD(map, dbn_length, dbn_angle_delta, dbn_z_delta): A sub-type for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nThese contain the following fields: \n\nmap: A field that defines the arena within which movement occurs. The coordinate reference system of the map must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. map is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelMoveXYZ, simply define a struct that is a sub-type of Patter.ModelMove:\n\nstruct ModelMoveXYZ{T, U, V, W} <: Patter.ModelMove\n    # The environment (i.e., map)\n    # > This defines the regions within which movements are permitted (i.e., in water)\n    map::T\n    # Distribution for step lengths\n    dbn_length::U\n    # Distribution for turning angles\n    dbn_angle::V\n    # Distribution for changes in depth\n    dbn_z_delta::W\n  end\n\nNew ModelMove structures should obey the following requirements:\n\nThe map field is required by all ModelMove sub-types; \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\n\nTo use a new ModelMove sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding State sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObs","page":"Patter.jl","title":"Patter.ModelObs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsAcousticLogisTrunc","page":"Patter.jl","title":"Patter.ModelObsAcousticLogisTrunc","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsDepthNormalTrunc","page":"Patter.jl","title":"Patter.ModelObsDepthNormalTrunc","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsDepthUniform","page":"Patter.jl","title":"Patter.ModelObsDepthUniform","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.State","page":"Patter.jl","title":"Patter.State","text":"State\n\nState is an Abstract Type that defines the animal's state at a given time step. \n\nBuilt-in sub-types\n\nThe following sub-types are built-in:\n\nStateXY(map_value, x, y): Used for two dimensional (x, y) states ;\nStateXYZD(map_value, x, y, z, angle): Used for four-dimensional (x, y, z, direction) states;\n\nThese contain the following fields: \n\nmap_value: The value of the movement map at coordinates (x, y), required for all States (see ModelMove);\nx, y:  Floats that define the animal's x and y coordinates, required for all States;\nz: A float that defines the animal's z (depth) coordinate, required for all States with a depth component;\nangle: A float that defines the turning angle, required by StateXYZD;\n\nCustom sub-types\n\nTo define a custom sub-type, such as StateXYZ, simply define a struct that is a sub-type of Patter.State:\n\nstruct StateXYZ <: Patter.State\n    # Map value\n    map_value::Float64\n    # Coordinates\n    x::Float64\n    y::Float64\n    z::Float64\nend\n\nNew states should obey the following requirements:\n\nAll states must include map_value, x and y fields;\nFor states with a depth dimension, the depth field must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\nTo use a new State sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding ModelMove sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXY","page":"Patter.jl","title":"Patter.StateXY","text":"State\n\nState is an Abstract Type that defines the animal's state at a given time step. \n\nBuilt-in sub-types\n\nThe following sub-types are built-in:\n\nStateXY(map_value, x, y): Used for two dimensional (x, y) states ;\nStateXYZD(map_value, x, y, z, angle): Used for four-dimensional (x, y, z, direction) states;\n\nThese contain the following fields: \n\nmap_value: The value of the movement map at coordinates (x, y), required for all States (see ModelMove);\nx, y:  Floats that define the animal's x and y coordinates, required for all States;\nz: A float that defines the animal's z (depth) coordinate, required for all States with a depth component;\nangle: A float that defines the turning angle, required by StateXYZD;\n\nCustom sub-types\n\nTo define a custom sub-type, such as StateXYZ, simply define a struct that is a sub-type of Patter.State:\n\nstruct StateXYZ <: Patter.State\n    # Map value\n    map_value::Float64\n    # Coordinates\n    x::Float64\n    y::Float64\n    z::Float64\nend\n\nNew states should obey the following requirements:\n\nAll states must include map_value, x and y fields;\nFor states with a depth dimension, the depth field must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\nTo use a new State sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding ModelMove sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXYZ","page":"Patter.jl","title":"Patter.StateXYZ","text":"State\n\nState is an Abstract Type that defines the animal's state at a given time step. \n\nBuilt-in sub-types\n\nThe following sub-types are built-in:\n\nStateXY(map_value, x, y): Used for two dimensional (x, y) states ;\nStateXYZD(map_value, x, y, z, angle): Used for four-dimensional (x, y, z, direction) states;\n\nThese contain the following fields: \n\nmap_value: The value of the movement map at coordinates (x, y), required for all States (see ModelMove);\nx, y:  Floats that define the animal's x and y coordinates, required for all States;\nz: A float that defines the animal's z (depth) coordinate, required for all States with a depth component;\nangle: A float that defines the turning angle, required by StateXYZD;\n\nCustom sub-types\n\nTo define a custom sub-type, such as StateXYZ, simply define a struct that is a sub-type of Patter.State:\n\nstruct StateXYZ <: Patter.State\n    # Map value\n    map_value::Float64\n    # Coordinates\n    x::Float64\n    y::Float64\n    z::Float64\nend\n\nNew states should obey the following requirements:\n\nAll states must include map_value, x and y fields;\nFor states with a depth dimension, the depth field must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\nTo use a new State sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding ModelMove sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXYZD","page":"Patter.jl","title":"Patter.StateXYZD","text":"State\n\nState is an Abstract Type that defines the animal's state at a given time step. \n\nBuilt-in sub-types\n\nThe following sub-types are built-in:\n\nStateXY(map_value, x, y): Used for two dimensional (x, y) states ;\nStateXYZD(map_value, x, y, z, angle): Used for four-dimensional (x, y, z, direction) states;\n\nThese contain the following fields: \n\nmap_value: The value of the movement map at coordinates (x, y), required for all States (see ModelMove);\nx, y:  Floats that define the animal's x and y coordinates, required for all States;\nz: A float that defines the animal's z (depth) coordinate, required for all States with a depth component;\nangle: A float that defines the turning angle, required by StateXYZD;\n\nCustom sub-types\n\nTo define a custom sub-type, such as StateXYZ, simply define a struct that is a sub-type of Patter.State:\n\nstruct StateXYZ <: Patter.State\n    # Map value\n    map_value::Float64\n    # Coordinates\n    x::Float64\n    y::Float64\n    z::Float64\nend\n\nNew states should obey the following requirements:\n\nAll states must include map_value, x and y fields;\nFor states with a depth dimension, the depth field must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\nTo use a new State sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding ModelMove sub-type;\n(optional) Define a Patter.simulate_state_init() method for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in two_filter_smoother());\n\n\n\n\n\n","category":"type"},{"location":"#Index","page":"Patter.jl","title":"Index","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"}]
}
