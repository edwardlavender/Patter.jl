var documenterSearchIndex = {"docs":
[{"location":"#Patter.jl","page":"Patter.jl","title":"Patter.jl","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"},{"location":"#Functions","page":"Patter.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"Modules = [Patter]\nOrder   = [:function, :type]","category":"page"},{"location":"#Patter.abs_angle_difference-Tuple{Any, Any}","page":"Patter.jl","title":"Patter.abs_angle_difference","text":"Compute the smallest absolute rotation between two angles\n\n\n\n\n\n","category":"method"},{"location":"#Patter.assemble_yobs-Tuple{Vector, Vector{DataType}}","page":"Patter.jl","title":"Patter.assemble_yobs","text":"# Assemble `yobs` for the particle filter\n\nAssemble a dictionary of observations (and associated model parameters) for the particle filter. \n\nArguments\n\ndatasets: A Vector of DataFrames, one for each data type. Each DataFrame must contain the following columns:\ntimestamp: A DateTime Vector of time stamps;\nsensor_id: A vector of sensor IDs;\nobs: The observation;\nAdditional columns required to construct ModelObs instances (that is, model parameters);\nmodel_types: A Vector of ModelObs subtypes for each dataset. \n\nDetails\n\nThe function iterates over datasets and models and creates a typed dictionary of timestamps. Each time step contains a vector of Tuples, with one element for each sensor that recorded an observation at that time stamp. Each element is a tuple that defines the observation and the model parameters (that is, a ModelObs instance).\n\n\n\n\n\n","category":"method"},{"location":"#Patter.cartesian_to_polar-Tuple{Any, Any}","page":"Patter.jl","title":"Patter.cartesian_to_polar","text":"Cartesian to polar coordinates\n\n\n\n\n\n","category":"method"},{"location":"#Patter.distance","page":"Patter.jl","title":"Patter.distance","text":"distance(x0::Real, y0::Real, x1::Real, y1::Real)\n\nCalculate Euclidean distances between coordinates. \n\nArguments\n\nx0, y0: The coordinates of the first point;\nx1, y1: The coordinates of the second point;\n\nReturns\n\nA number that defines the distance between two coordinates.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.ext-Tuple{Vector{Real}}","page":"Patter.jl","title":"Patter.ext","text":"Define extent object\n\nDesigned to match GeoArray.bbox() For passing bounding box from R\n\n\n\n\n\n","category":"method"},{"location":"#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}","page":"Patter.jl","title":"Patter.extract","text":"extract(map::GeoArrays.GeoArray, x::Real, y::Real)\n\nExtract the value of a GeoArray (such as a bathymetry grid) at a specififed pair of x and y coordinates.\n\nDetails\n\nIn Patter.jl, NaN elements are taken to define inhospitable habitats, such as land (see is_valid()). \n\nTo extract a value from a map in another format, such as a shapefile, write a custom extract() method.\n\nReturns\n\nThe value of the GeoArray for a coordinate pair within the bounds of map;\nNaN (of the same type as map's elements) for a coordinate pair beyond the bounds of map;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.in_bbox-Tuple{Any, Any, Any}","page":"Patter.jl","title":"Patter.in_bbox","text":"Determine whether or not a coordinate (x, y) is within a boundary box.\n\n\n\n\n\n","category":"method"},{"location":"#Patter.is_valid","page":"Patter.jl","title":"Patter.is_valid","text":"is_valid(map_value::Real)\nis_valid(map_valu::Real, z::Real)\n\nDetermine the validity of a point on a map.\n\nFor 2D (x, y) states, is_valid(map_value) checks if the map_value at point (x, y) is not NaN.\n\nFor 3D (x, y, z) states, is_valid(map_value, z), checks that map_value at point (x, y) is not NaN, and also ensures that the provided z-coordinate (z) lies within the valid range, specifically 0 < z â‰¤ map_value.\n\nArguments\n\nmap_value: The map from which z-coordinates are extracted;\nx: The x-coordinate of the point;\ny: The y-coordinate of the point;\nz: The z-coordinate of the point to be validated (only for the 3D case);\n\nReturns\n\ntrue if the conditions for validity are met;\nfalse otherwise;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get","page":"Patter.jl","title":"Patter.julia_get","text":"Julia from R\n\nA collection of functions that facilitate the translation of inputs from R into Julia.\n\nDetails\n\n[julia_get_xinit()] gets a Vector of initial States from a DataFrame;\n[julia_get_model_types()] gets a Vector of ModelObs subtypes from a Vector of Strings;\n[julia_get_models()] gets a Vector of model instances from a Vector of DataFrames that contain parameters and a corresponding vector of model types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get_xinit","page":"Patter.jl","title":"Patter.julia_get_xinit","text":"Julia from R\n\nA collection of functions that facilitate the translation of inputs from R into Julia.\n\nDetails\n\n[julia_get_xinit()] gets a Vector of initial States from a DataFrame;\n[julia_get_model_types()] gets a Vector of ModelObs subtypes from a Vector of Strings;\n[julia_get_models()] gets a Vector of model instances from a Vector of DataFrames that contain parameters and a corresponding vector of model types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_move","page":"Patter.jl","title":"Patter.logpdf_move","text":"Calculate the logpdf of a restricted movement\n\nAn internal function that calculates the logpdf of a movement from one state to another. \n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_obs","page":"Patter.jl","title":"Patter.logpdf_obs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in subtypes. \n\nBuilt-in subtypes\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndeep_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all subtypes should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_step-Tuple{StateXY, StateXY, ModelMoveXY, Float64, Float64}","page":"Patter.jl","title":"Patter.logpdf_step","text":"Calculate the unnormalised logpdf of an (unrestricted) movement step\n\nDetails\n\nlogpdfstep() is wrapped by the internal logpdfmove() function\nFor new states, a corresponding logpdf_step() method is required\nlogpdf_move() accounts for restricted steps, the determinate and the normalisation\n\n\n\n\n\n","category":"method"},{"location":"#Patter.particle_filter-Tuple{}","page":"Patter.jl","title":"Patter.particle_filter","text":"Particle filter\n\nA particle filtering algorithm that samples from f(X_t | {Y_1 ... Y_t}) for t âˆˆ 1:Tmax.\n\nArguments\n\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation.\nxinit: A Vector of State instances that defines the initial state(s) of the animal.\nyobs: A Dictionary of observations (see assemble_yobs()):         - Dictionary keys should match elements in timeline.        - Each element must be a Vector of Tuples for that time step (one for each observation/sensor).         - Each Tuple should contain (a) the observation and (b) the model parameters (that is, a ModelObs instance).\nmove: A ModelMove instance.\nThe movement model describes movement from one time step to the next and therefore depends implicitly on the resolution of timeline.\nThe movement model should align with the [State] instances in .xinit. For example, a 2-dimensional state (StateXY) requires a corresponding movement model instance (i.e., ModelMoveXY). \nn_move: An integer that defines the number of attempts used to find a legal move. \nAll ModelMove subtypes contain a map field that defines the region(s) within which movements are allowed.\nEach particle is moved up to n_move times, until a valid movement is simulated. \nParticles that fail to generate a valid move are killed. \nn_record: An integer that defines the number of particles to record at each time step.\nn_record particles are resampled at each time step and recorded in memory. \nn_resample: A number that defines the effective sample size for resampling.\nParticles are resampled when the effective sample size <= n_resample.\ndirection: A String that defines the direction of the filter.\n\"forward\" runs the filter forwards in time;\n\"backward\" runs the filter backwards in time;\n\nAlgorithm\n\nInitiation\n\nThe algorithm is initiated using a Vector of .n_particle States (.xinit). \n\nMovement\n\nFor every time step in the timeline, the internal function Patter.simulate_move() simulates the movement of particles away from previous states into new states using the movement model specified by .model_move. Patter.simulate_move() is an iterative wrapper for a Patter.simulate_step() method that simulates a new State instance from the previous State, using the movement model. Patter.simulate_move() implements Patter.simulate_step() iteratively until a legal move is found (or .n_move is reached). Illegal moves are those that land in NaN locations on the map or, in the case of states that include a depth (z) component, are below the depth of the seabed. Particles that fail to generate legal moves are eventually killed by re-sampling (see below).\n\nLikelihood\n\nFor each valid State and time stamp in yobs, the log-probability of each observation, given the State, is evaluated via Patter.logpdf_obs(). The maximum log-probability across all particles is recorded at each time step as an algorithm diagnostic.\n\nResampling\n\nParticles are periodically re-sampled, with replacement, using the low-variance systematic re-sampling algorithm (via resample()), when the effective sample size is less than or equal to .n_resample. This has the effect of eliminating impossible particles and duplicating likely ones.\n\nThe algorithm continues in this way, iterating over the timeline, simulating, weighting and (re)sampling particles. At each time step, .n_record particles are saved in memory. If the function fails to converge, a [warning] is returned alongside the outputs up to that time step. Otherwise, the function will continue to the end of the time series.\n\nMulti-threading\n\nThe iteration over particles (i.e., simulated movements and likelihood evaluations) are multi-threaded. \n\nConvergence and diagnostics\n\nAlgorithm convergence is not guaranteed. The algorithm may reach a dead-endâ€“-a time step at which there are no valid locations into which the algorithm can step. This may be due to data errors, incorrect assumptions, insufficient sampling effort or poor tuning-parameter settings.\n\nReturns\n\nA NamedTuple with the following fields:\n\ntimesteps: An Vector{Int64} of time steps;\ntimestamps: The timeline;\ndirection: The direction;\nstate: A Matrix of States:\nEach row corresponds to a particle; \nEach column corresponds to the timestep;\ness: A Vector{Float64} that defines the effective sample size at each time step;\nmaxlp: A Vector{Float64} that defines the maximum log-posterior at each time step;\nconvergence: A Bool that defines whether or not the algorithm reached the end of the timeline;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.r_get_states","page":"Patter.jl","title":"Patter.r_get_states","text":"R from Julia\n\nA collection of functions that facilitate the translation of inputs from Julia into R. \n\nDetails\n\n[r_get_states] translates a State matrix into a DataFrame that can be passed to R. In the input matrix, each row is a particle and each column is a time step. \n[r_get_dataset] translates a Dictionary of observations into a Vector of DataFrames that can be passed to R.\n\nReturns\n\nA long-format DataFrame, with columns for path_id, timestep and each state dimension.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.resample","page":"Patter.jl","title":"Patter.resample","text":"Systematic resampling algorithm\n\nGiven the weight vector w, resample a set of indices based on low-variance resampling algorithm from Thrun, Burgard, and Fox's \"Probabilistic Robotics\".\n\nSource\n\nCode adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.\n\nExample\n\nX = [\"A\", \"B\", \"C\", \"D\"]\nw = [0, 0, 0.75, 0.25]\n\nidx = resample(w, 12)\nX[idx]\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_move","page":"Patter.jl","title":"Patter.simulate_move","text":"simulate_move(state::State, model::MoveModel, t::Int64, n_trial::Real)\n\nSimulate movement from one location (State) into a new location (State).\n\nDetails\n\nsimulate_move() is an internal function that uses an Patter.simulate_step() method to simulate proposals for a new state until a valid proposal is generated;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_obs","page":"Patter.jl","title":"Patter.simulate_obs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in subtypes. \n\nBuilt-in subtypes\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndeep_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all subtypes should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_path_walk-Tuple{}","page":"Patter.jl","title":"Patter.simulate_path_walk","text":"Simulate movement paths\n\nThis function simulates discrete-time movement path(s) from a vector of initial states and random-walk movement model. \n\nArguments\n\nxinit: A Vector of States that defines the initial state(s) for the simulation;\nmove: A ModelMove instance;\nnt: An integer that defines the number of time steps;\n\nDetails\n\nFor each initial state, a movement path is simulated. \n\nReturns\n\nA matrix:\n\nRows: paths\nColumns: time steps\n\n\n\n\n\n","category":"method"},{"location":"#Patter.simulate_state_init","page":"Patter.jl","title":"Patter.simulate_state_init","text":"simulatestateinit(state::State, model::MoveModel, xlim, ylim)\n\nSimulate an initial state.\n\nThis function is wrapped by the exported function simulate_states_init(), which simulates a vector of states.\n\nArguments:\n\nstate_type: An empty State subtype, such as StateXY, used for method dispatch only;\nmodel: A MoveModel instance;\nxlim, ylim: Pairs of numbers that define the boundaries of the area within which x and y state values are sampled;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_states_init","page":"Patter.jl","title":"Patter.simulate_states_init","text":"Simulate initial states\n\nSimulate a vector of initial states for the simulation of movement paths and the particle filter.\n\nArguments\n\nstate_type: An empty State subtype, such as StateXY, used for method dispatch only;\nmove: A MoveModel instance;\nn: The number of intial states to simulate;\nxlim, ylim: (optional) Pairs of numbers that define the boundaries of the area within which x and y state values are sampled;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_step","page":"Patter.jl","title":"Patter.simulate_step","text":"simulate_step(state::State, model::ModelMove, t::Int64)\n\nSimulate a (tentative) step from one location (State) into a new location (State).\n\nDetails\n\nsimulate_step() is a generic function that simulates a new value for the animal's state;\nDifferent methods are dispatched according to the state and the movement model;\nNew methods must be provided for custom states or movement models;\nInternally, simulate_step() is wrapped by simulate_move(), which implements simulate_step() iteratively until a valid proposal is generated;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_yobs-Tuple{}","page":"Patter.jl","title":"Patter.simulate_yobs","text":"Simulate observations\n\nFor each simulated path, simulate a dictionary of observations. \n\nArguments\n\npaths: A Matrix of simulated paths; from simulate_path_walk();\nmodels: A Vector of ModelObs instances;\ntimeline: A Vector{DateTime} of time stamps;\n\nReturns\n\nA dictionary, with one entry for each path;\nEach entry is a dictionary, with one entry for each time stamp;\nEach time stamp entry is a Vector of Tuples, each comprising the observation and the associated ModelObs instance;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.state_is_valid-Tuple{State, Bool}","page":"Patter.jl","title":"Patter.state_is_valid","text":"state_is_valid(state::State, zdim::Bool)\n\nDetermine whether or not a state is valid.\n\nSee also State, is_valid(), \n\n\n\n\n\n","category":"method"},{"location":"#Patter.two_filter_smoother-Tuple{}","page":"Patter.jl","title":"Patter.two_filter_smoother","text":"Two filter smoother\n\nFearnhead, P., Wyncoll, D., Tawn, J., 2010. A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447â€“464. https://doi.org/10.1093/biomet/asq013\n\n\n\n\n\n","category":"method"},{"location":"#Patter.ModelMove","page":"Patter.jl","title":"Patter.ModelMove","text":"Movement models\n\nModelMove is an abstract type that defines the movement model. \n\nSubtypes\n\n`: A subtype for two-dimensional (x, y) random walks, based distributions for step lengths (dbnlength) and turning angles (dbnangle`);\nModelMoveXY: A subtype for three-dimensional (x, y, z) random walks, based on distributions for step lengths (dbn_length), turning angles (dbn_angle) and changes in depth (dbn_z_delta);\nModelMoveXYZD: A subtype for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nFields\n\nmap: A field that defines the arena within which movement occurs. This is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nDetails\n\nModelMove structures define the parameters of the movement model;\nAll ModelMove structures must contain an map field. \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\nUsers can use a provided structure or write their own;\nFor custom ModelMoves, new rstep() methods are required;\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelMoveXY","page":"Patter.jl","title":"Patter.ModelMoveXY","text":"Movement models\n\nModelMove is an abstract type that defines the movement model. \n\nSubtypes\n\n`: A subtype for two-dimensional (x, y) random walks, based distributions for step lengths (dbnlength) and turning angles (dbnangle`);\nModelMoveXY: A subtype for three-dimensional (x, y, z) random walks, based on distributions for step lengths (dbn_length), turning angles (dbn_angle) and changes in depth (dbn_z_delta);\nModelMoveXYZD: A subtype for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nFields\n\nmap: A field that defines the arena within which movement occurs. This is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nDetails\n\nModelMove structures define the parameters of the movement model;\nAll ModelMove structures must contain an map field. \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\nUsers can use a provided structure or write their own;\nFor custom ModelMoves, new rstep() methods are required;\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelMoveXYZD","page":"Patter.jl","title":"Patter.ModelMoveXYZD","text":"Movement models\n\nModelMove is an abstract type that defines the movement model. \n\nSubtypes\n\n`: A subtype for two-dimensional (x, y) random walks, based distributions for step lengths (dbnlength) and turning angles (dbnangle`);\nModelMoveXY: A subtype for three-dimensional (x, y, z) random walks, based on distributions for step lengths (dbn_length), turning angles (dbn_angle) and changes in depth (dbn_z_delta);\nModelMoveXYZD: A subtype for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nFields\n\nmap: A field that defines the arena within which movement occurs. This is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nDetails\n\nModelMove structures define the parameters of the movement model;\nAll ModelMove structures must contain an map field. \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\nUsers can use a provided structure or write their own;\nFor custom ModelMoves, new rstep() methods are required;\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObs","page":"Patter.jl","title":"Patter.ModelObs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in subtypes. \n\nBuilt-in subtypes\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndeep_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all subtypes should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsAcousticLogisTrunc","page":"Patter.jl","title":"Patter.ModelObsAcousticLogisTrunc","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in subtypes. \n\nBuilt-in subtypes\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndeep_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all subtypes should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsDepthNormalTrunc","page":"Patter.jl","title":"Patter.ModelObsDepthNormalTrunc","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in subtypes. \n\nBuilt-in subtypes\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndeep_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all subtypes should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsDepthUniform","page":"Patter.jl","title":"Patter.ModelObsDepthUniform","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in subtypes. \n\nBuilt-in subtypes\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniform\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by two error terms (depth_shallow_eps and depth_shallow_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs().\n\nModelObsDepthNormalTrunc\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndeep_depth_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the bathymetric depth, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all subtypes should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.State","page":"Patter.jl","title":"Patter.State","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXY","page":"Patter.jl","title":"Patter.StateXY","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXYZ","page":"Patter.jl","title":"Patter.StateXYZ","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXYZD","page":"Patter.jl","title":"Patter.StateXYZD","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Index","page":"Patter.jl","title":"Index","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"}]
}
