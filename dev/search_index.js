var documenterSearchIndex = {"docs":
[{"location":"#Patter.jl","page":"Patter.jl","title":"Patter.jl","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"},{"location":"#Functions","page":"Patter.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"Modules = [Patter]\nOrder   = [:function, :type]","category":"page"},{"location":"#Patter.assemble_yobs-Tuple{Vector, Vector{DataType}}","page":"Patter.jl","title":"Patter.assemble_yobs","text":"# Assemble `yobs` for the particle filter\n\nAssemble a dictionary of observations (and associated model parameters) for the particle filter. \n\nArguments\n\ndatasets: A Vector of DataFrames, one for each data type. Each DataFrame must contain the following columns:\ntimestamp: A DateTime Vector of time stamps;\nsensor_id: A vector of sensor IDs;\nobs: The observation;\nAdditional columns required to construct ModelObs instances (that is, model parameters);\nmodel_types: A Vector of ModelObs subtypes for each dataset. \n\nDetails\n\nThe function iterates over datasets and models and creates a typed dictionary of timestamps. Each time step contains a vector of Tuples, with one element for each sensor that recorded an observation at that time stamp. Each element is a tuple that defines the observation and the model parameters (that is, a ModelObs instance).\n\n\n\n\n\n","category":"method"},{"location":"#Patter.distance","page":"Patter.jl","title":"Patter.distance","text":"distance(x0::Real, y0::Real, x1::Real, y1::Real)\n\nCalculate Euclidean distances between coordinates. \n\nArguments\n\nx0, y0: The coordinates of the first point;\nx1, y1: The coordinates of the second point;\n\nReturns\n\nA number that defines the distance between two coordinates.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}","page":"Patter.jl","title":"Patter.extract","text":"extract(map::GeoArrays.GeoArray, x::Real, y::Real)\n\nExtract the value of a GeoArray (such as a bathymetry grid) at a specififed pair of x and y coordinates.\n\nDetails\n\nIn Patter.jl, NaN elements are taken to define inhospitable habitats, such as land (see is_valid()). \n\nTo extract a value from a map in another format, such as a shapefile, write a custom extract() method.\n\nReturns\n\nThe value of the GeoArray for a coordinate pair within the bounds of map;\nNaN (of the same type as map's elements) for a coordinate pair beyond the bounds of map;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.is_valid","page":"Patter.jl","title":"Patter.is_valid","text":"is_valid(map_value::Real)\nis_valid(map_valu::Real, z::Real)\n\nDetermine the validity of a point on a map.\n\nFor 2D (x, y) states, is_valid(map_value) checks if the map_value at point (x, y) is not NaN.\n\nFor 3D (x, y, z) states, is_valid(map_value, z), checks that map_value at point (x, y) is not NaN, and also ensures that the provided z-coordinate (z) lies within the valid range, specifically 0 < z ≤ map_value.\n\nArguments\n\nmap_value: The map from which z-coordinates are extracted;\nx: The x-coordinate of the point;\ny: The y-coordinate of the point;\nz: The z-coordinate of the point to be validated (only for the 3D case);\n\nReturns\n\ntrue if the conditions for validity are met;\nfalse otherwise;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get","page":"Patter.jl","title":"Patter.julia_get","text":"Julia from R\n\nA collection of functions that facilitate the translation of inputs from R into Julia.\n\nDetails\n\n[julia_get_xinit()] gets a Vector of initial States from a DataFrame;\n[julia_get_model_types()] gets a Vector of ModelObs subtypes from a Vector of Strings;\n[julia_get_models()] gets a Vector of model instances from a Vector of DataFrames that contain parameters and a corresponding vector of model types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.julia_get_xinit","page":"Patter.jl","title":"Patter.julia_get_xinit","text":"Julia from R\n\nA collection of functions that facilitate the translation of inputs from R into Julia.\n\nDetails\n\n[julia_get_xinit()] gets a Vector of initial States from a DataFrame;\n[julia_get_model_types()] gets a Vector of ModelObs subtypes from a Vector of Strings;\n[julia_get_models()] gets a Vector of model instances from a Vector of DataFrames that contain parameters and a corresponding vector of model types;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_obs","page":"Patter.jl","title":"Patter.logpdf_obs","text":"Observation models\n\nStructures\n\nModelObs is an abstract type used to hold parameters for observation models. For communication with R, all subtypes should include a sensor_id field. \n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation and a truncated logistic detection probability model:\n\nsensor_id: The receiver ID;\nreceiver_x, receiver_y: The coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: The parameters of a logistic detection probability model;\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model, in which we assume the individual must be located in an envelope around the bathymetry depth, defined by two error terms:\n\nsensor_id: The sensor ID;\ndepth_shallow_eps\ndepth_deep_eps\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model, in which we assume the likelihood of a depth observation given by a normal distribution centred at the bathymetric depth in a location and defined by the parameters:\n\nsensor_id: The sensor ID;\ndepth_sigma: The standard deviation of the normal distribution;\ndeep_depth_eps: The deep truncation parameter;\n\nSimulation\n\nsimulate_obs() is a generic function that simulates observations from a ModelObs instance. \n\nDensity\n\nlogpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's state and a ModelObs instance.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.particle_filter-Tuple{}","page":"Patter.jl","title":"Patter.particle_filter","text":"Particle filter\n\nA particle filtering algorithm that samples from f(Xt | {Y1 ... Y_t}) for t ∈ 1:Tmax.\n\nArguments:\n\ntimeline: A Vector{DateTime} of time stamps that defines the time steps for the simulation. Time stamps must be equally spaced.\nxinit: A Vector{State} that defines the initial state(s) of the animal.\nyobs: A Dictionary of observations.\nmove: A ModelMove instance.\nn_move: An integer that defines the number of attempts used to find a legal move. Particles are killed otherwise.\nn_record: An integer that defines the number of particles to record at each time step.\nn_resample: A number that defines the effective sample size at which to resample particles.\n\nReturns\n\nA tuple with the following fields:\n\ntimeline\nstate\ness\nmaxlp\nconvergence\n\n\n\n\n\n","category":"method"},{"location":"#Patter.r_get_states-Tuple{Matrix}","page":"Patter.jl","title":"Patter.r_get_states","text":"R from Julia\n\nA collection of functions that facilitate the translation of inputs from Julia into R. \n\nDetails\n\n[r_get_states] translates a State matrix into a DataFrame that can be passed to R. In the input matrix, each row is a particle and each column is a time step. \n[r_get_dataset] translates a Dictionary of observations into a Vector of DataFrames that can be passed to R.\n\nReturns\n\nA long-format DataFrame, with columns for path_id, timestep and each state dimension.\n\n\n\n\n\n","category":"method"},{"location":"#Patter.resample","page":"Patter.jl","title":"Patter.resample","text":"Systematic resampling algorithm\n\nGiven the weight vector w, resample a set of indices based on low-variance resampling algorithm from Thrun, Burgard, and Fox's \"Probabilistic Robotics\".\n\nSource\n\nCode adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.\n\nExample\n\nX = [\"A\", \"B\", \"C\", \"D\"]\nw = [0, 0, 0.75, 0.25]\n\nidx = resample(w, 12)\nX[idx]\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_move","page":"Patter.jl","title":"Patter.simulate_move","text":"simulate_move(state::State, model::MoveModel, t::Int64, n_trial::Real)\n\nSimulate movement from one location (State) into a new location (State).\n\nDetails\n\nsimulate_move() is an internal function that uses an Patter.simulate_step() method to simulate proposals for a new state until a valid proposal is generated;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_obs","page":"Patter.jl","title":"Patter.simulate_obs","text":"Observation models\n\nStructures\n\nModelObs is an abstract type used to hold parameters for observation models. For communication with R, all subtypes should include a sensor_id field. \n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation and a truncated logistic detection probability model:\n\nsensor_id: The receiver ID;\nreceiver_x, receiver_y: The coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: The parameters of a logistic detection probability model;\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model, in which we assume the individual must be located in an envelope around the bathymetry depth, defined by two error terms:\n\nsensor_id: The sensor ID;\ndepth_shallow_eps\ndepth_deep_eps\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model, in which we assume the likelihood of a depth observation given by a normal distribution centred at the bathymetric depth in a location and defined by the parameters:\n\nsensor_id: The sensor ID;\ndepth_sigma: The standard deviation of the normal distribution;\ndeep_depth_eps: The deep truncation parameter;\n\nSimulation\n\nsimulate_obs() is a generic function that simulates observations from a ModelObs instance. \n\nDensity\n\nlogpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's state and a ModelObs instance.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_path_walk-Tuple{}","page":"Patter.jl","title":"Patter.simulate_path_walk","text":"Simulate movement paths\n\nThis function simulates discrete-time movement path(s) from a vector of initial states and random-walk movement model. \n\nArguments\n\nxinit: A Vector of States that defines the initial state(s) for the simulation;\nmove: A ModelMove instance;\nnt: An integer that defines the number of time steps;\n\nDetails\n\nFor each initial state, a movement path is simulated. \n\nReturns\n\nA matrix:\n\nRows: paths\nColumns: time steps\n\n\n\n\n\n","category":"method"},{"location":"#Patter.simulate_state_init","page":"Patter.jl","title":"Patter.simulate_state_init","text":"simulatestateinit(state::State, model::MoveModel, xlim, ylim)\n\nSimulate an initial state.\n\nThis function is wrapped by the exported function simulate_states_init(), which simulates a vector of states.\n\nArguments:\n\nstate_type: An empty State subtype, such as StateXY, used for method dispatch only;\nmodel: A MoveModel instance;\nxlim, ylim: Pairs of numbers that define the boundaries of the area within which x and y state values are sampled;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_states_init","page":"Patter.jl","title":"Patter.simulate_states_init","text":"Simulate initial states\n\nSimulate a vector of initial states for the simulation of movement paths and the particle filter.\n\nArguments\n\nstate_type: An empty State subtype, such as StateXY, used for method dispatch only;\nmove: A MoveModel instance;\nn: The number of intial states to simulate;\nxlim, ylim: (optional) Pairs of numbers that define the boundaries of the area within which x and y state values are sampled;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_step","page":"Patter.jl","title":"Patter.simulate_step","text":"simulate_step(state::State, model::ModelMove, t::Int64)\n\nSimulate a (tentative) step from one location (State) into a new location (State).\n\nDetails\n\nsimulate_step() is a generic function that simulates a new value for the animal's state;\nDifferent methods are dispatched according to the state and the movement model;\nNew methods must be provided for custom states or movement models;\nInternally, simulate_step() is wrapped by simulate_move(), which implements simulate_step() iteratively until a valid proposal is generated;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_yobs-Tuple{}","page":"Patter.jl","title":"Patter.simulate_yobs","text":"Simulate observations\n\nFor each simulated path, simulate a dictionary of observations. \n\nArguments\n\npaths: A Matrix of simulated paths; from simulate_path_walk();\nmodels: A Vector of ModelObs instances;\ntimeline: A Vector{DateTime} of time stamps;\n\nReturns\n\nA dictionary, with one entry for each path;\nEach entry is a dictionary, with one entry for each time stamp;\nEach time stamp entry is a Vector of Tuples, each comprising the observation and the associated ModelObs instance;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.state_is_valid-Tuple{State, Bool}","page":"Patter.jl","title":"Patter.state_is_valid","text":"state_is_valid(state::State, zdim::Bool)\n\nDetermine whether or not a state is valid.\n\nSee also State, is_valid(), \n\n\n\n\n\n","category":"method"},{"location":"#Patter.ModelMove","page":"Patter.jl","title":"Patter.ModelMove","text":"Movement models\n\nModelMove is an abstract type that defines the movement model. \n\nSubtypes\n\nMoveModelXY: A subtype for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and turning angles (dbn_angle);\nMoveModelXYZ: A subtype for three-dimensional (x, y, z) random walks, based on distributions for step lengths (dbn_length), turning angles (dbn_angle) and changes in depth (dbn_z_delta);\nMoveModelXYZD: A subtype for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nFields\n\nmap: A field that defines the arena within which movement occurs. This is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nDetails\n\nModelMove structures define the parameters of the movement model;\nAll ModelMove structures must contain an map field. \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\nUsers can use a provided structure or write their own;\nFor custom ModelMoves, new rstep() methods are required;\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelMoveXY","page":"Patter.jl","title":"Patter.ModelMoveXY","text":"Movement models\n\nModelMove is an abstract type that defines the movement model. \n\nSubtypes\n\nMoveModelXY: A subtype for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and turning angles (dbn_angle);\nMoveModelXYZ: A subtype for three-dimensional (x, y, z) random walks, based on distributions for step lengths (dbn_length), turning angles (dbn_angle) and changes in depth (dbn_z_delta);\nMoveModelXYZD: A subtype for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nFields\n\nmap: A field that defines the arena within which movement occurs. This is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nDetails\n\nModelMove structures define the parameters of the movement model;\nAll ModelMove structures must contain an map field. \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\nUsers can use a provided structure or write their own;\nFor custom ModelMoves, new rstep() methods are required;\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelMoveXYZD","page":"Patter.jl","title":"Patter.ModelMoveXYZD","text":"Movement models\n\nModelMove is an abstract type that defines the movement model. \n\nSubtypes\n\nMoveModelXY: A subtype for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and turning angles (dbn_angle);\nMoveModelXYZ: A subtype for three-dimensional (x, y, z) random walks, based on distributions for step lengths (dbn_length), turning angles (dbn_angle) and changes in depth (dbn_z_delta);\nMoveModelXYZD: A subtype for four-dimensional (correlated) random walks, based on distributions for step lengths (dbn_length), changes in turning angle (dbn_angle) and changes in depth (dbn_z_delta);\n\nFields\n\nmap: A field that defines the arena within which movement occurs. This is required by all movement models;\ndbn_length: The distribution of step lengths;\ndbn_angle: The distribution of turning angles;\ndbn_angle_delta: The distribution of changes in turning angle;\ndbn_z_delta: The distribution of changes in depth;\n\nDetails\n\nModelMove structures define the parameters of the movement model;\nAll ModelMove structures must contain an map field. \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\nUsers can use a provided structure or write their own;\nFor custom ModelMoves, new rstep() methods are required;\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObs","page":"Patter.jl","title":"Patter.ModelObs","text":"Observation models\n\nStructures\n\nModelObs is an abstract type used to hold parameters for observation models. For communication with R, all subtypes should include a sensor_id field. \n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation and a truncated logistic detection probability model:\n\nsensor_id: The receiver ID;\nreceiver_x, receiver_y: The coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: The parameters of a logistic detection probability model;\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model, in which we assume the individual must be located in an envelope around the bathymetry depth, defined by two error terms:\n\nsensor_id: The sensor ID;\ndepth_shallow_eps\ndepth_deep_eps\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model, in which we assume the likelihood of a depth observation given by a normal distribution centred at the bathymetric depth in a location and defined by the parameters:\n\nsensor_id: The sensor ID;\ndepth_sigma: The standard deviation of the normal distribution;\ndeep_depth_eps: The deep truncation parameter;\n\nSimulation\n\nsimulate_obs() is a generic function that simulates observations from a ModelObs instance. \n\nDensity\n\nlogpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's state and a ModelObs instance.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsAcousticLogisTrunc","page":"Patter.jl","title":"Patter.ModelObsAcousticLogisTrunc","text":"Observation models\n\nStructures\n\nModelObs is an abstract type used to hold parameters for observation models. For communication with R, all subtypes should include a sensor_id field. \n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation and a truncated logistic detection probability model:\n\nsensor_id: The receiver ID;\nreceiver_x, receiver_y: The coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: The parameters of a logistic detection probability model;\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model, in which we assume the individual must be located in an envelope around the bathymetry depth, defined by two error terms:\n\nsensor_id: The sensor ID;\ndepth_shallow_eps\ndepth_deep_eps\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model, in which we assume the likelihood of a depth observation given by a normal distribution centred at the bathymetric depth in a location and defined by the parameters:\n\nsensor_id: The sensor ID;\ndepth_sigma: The standard deviation of the normal distribution;\ndeep_depth_eps: The deep truncation parameter;\n\nSimulation\n\nsimulate_obs() is a generic function that simulates observations from a ModelObs instance. \n\nDensity\n\nlogpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's state and a ModelObs instance.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsDepthNormalTrunc","page":"Patter.jl","title":"Patter.ModelObsDepthNormalTrunc","text":"Observation models\n\nStructures\n\nModelObs is an abstract type used to hold parameters for observation models. For communication with R, all subtypes should include a sensor_id field. \n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation and a truncated logistic detection probability model:\n\nsensor_id: The receiver ID;\nreceiver_x, receiver_y: The coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: The parameters of a logistic detection probability model;\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model, in which we assume the individual must be located in an envelope around the bathymetry depth, defined by two error terms:\n\nsensor_id: The sensor ID;\ndepth_shallow_eps\ndepth_deep_eps\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model, in which we assume the likelihood of a depth observation given by a normal distribution centred at the bathymetric depth in a location and defined by the parameters:\n\nsensor_id: The sensor ID;\ndepth_sigma: The standard deviation of the normal distribution;\ndeep_depth_eps: The deep truncation parameter;\n\nSimulation\n\nsimulate_obs() is a generic function that simulates observations from a ModelObs instance. \n\nDensity\n\nlogpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's state and a ModelObs instance.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObsDepthUniform","page":"Patter.jl","title":"Patter.ModelObsDepthUniform","text":"Observation models\n\nStructures\n\nModelObs is an abstract type used to hold parameters for observation models. For communication with R, all subtypes should include a sensor_id field. \n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation and a truncated logistic detection probability model:\n\nsensor_id: The receiver ID;\nreceiver_x, receiver_y: The coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: The parameters of a logistic detection probability model;\n\nModelObsDepthUniform is ModelObs structure for a depth observation and a uniform depth model, in which we assume the individual must be located in an envelope around the bathymetry depth, defined by two error terms:\n\nsensor_id: The sensor ID;\ndepth_shallow_eps\ndepth_deep_eps\n\nModelObsDepthNormalTrunc is a ModelObs structure for a depth observation and a truncated normal model, in which we assume the likelihood of a depth observation given by a normal distribution centred at the bathymetric depth in a location and defined by the parameters:\n\nsensor_id: The sensor ID;\ndepth_sigma: The standard deviation of the normal distribution;\ndeep_depth_eps: The deep truncation parameter;\n\nSimulation\n\nsimulate_obs() is a generic function that simulates observations from a ModelObs instance. \n\nDensity\n\nlogpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's state and a ModelObs instance.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.State","page":"Patter.jl","title":"Patter.State","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXY","page":"Patter.jl","title":"Patter.StateXY","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXYZ","page":"Patter.jl","title":"Patter.StateXYZ","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Patter.StateXYZD","page":"Patter.jl","title":"Patter.StateXYZD","text":"State\n\nState is an abstract type that defines the animal's state at a given time step. \n\nSubtypes\n\nStateXY: Used for two dimensional (x, y) states;\nStateXYZ: Used for three-dimensional (x, y, z) states;\nStateXYZD: Used for four-dimensional (x, y, z, direction) states;\n\nFields\n\nmap_value: The value of the map at coordinates (x, y), required for All States;\nx, y:  The animal's x and y coordinates, required for all States;\nz: The animal's z coordinate, required for 3D States;\nangle: The turning angle, required by StateXYZD;\n\nDetails\n\nAll states must include x, y and map_value fields;\nFor >= 3D states, the depth dimension must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#Index","page":"Patter.jl","title":"Index","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"}]
}
