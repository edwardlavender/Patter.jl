var documenterSearchIndex = {"docs":
[{"location":"#Patter.jl","page":"Patter.jl","title":"Patter.jl","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"},{"location":"#Functions","page":"Patter.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"Modules = [Patter]\nOrder   = [:function, :type]","category":"page"},{"location":"#Patter.assemble_yobs-Tuple{}","page":"Patter.jl","title":"Patter.assemble_yobs","text":"assemble_yobs(; datasets::Vector, model_obs_types::Vector{DataType})\n\nAssemble a dictionary of observations (and associated model parameters) for the particle filter (particle_filter()). \n\nArguments (keywords)\n\ndatasets: A Vector of DataFrames, one for each data type. Each DataFrame must contain the following columns:\ntimestamp: A DateTime Vector of time stamps;\nsensor_id: A Vector of sensor IDs;\nobs: A Vector of observations;\nAdditional columns required to construct ModelObs instances (that is, model parameters);\nmodel_obs_types: A Vector of ModelObs sub-types (one for each dataset);\n\nDetails\n\nThe function iterates over animal-tracking datasets (for example, acoustic and archival [depth] time series for a particular individual) and corresponding observation model types and creates a typed dictionary of time stamps for the particle filter (see particle_filter()'s yobs argument). Each time step contains a Vector of Tuples, with one element for each sensor that recorded an observation at that time stamp. For example, each element might correspond to an acoustic receiver and/or the individual's archival tag. Each element is a Tuple that defines the observation and the corresponding observation model parameters (that is, a ModelObs instance). \n\nReturns\n\nA Dict:\nEach element corresponds to a timestamp:\nEach timestamped element contains a Vector of Tuples (one for each observation):\nEach Tuple contains an observation and the corresponding ModelObs instance;\n\nSee also\n\nassemble_yobs() to assemble real-world datasets for the particle filter;\nsimulate_yobs() to simulate observations for the particle filter;\nparticle_filter() to implement the particle filter;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.extract-Tuple{GeoArrays.GeoArray, Real, Real}","page":"Patter.jl","title":"Patter.extract","text":"extract(map::GeoArrays.GeoArray, x::Real, y::Real)\n\n(Internal) Extract the value of a GeoArray (such as a bathymetry grid) at a pair of x and y coordinates.\n\nDetails\n\nIn Patter.jl, map is a GeoArray that defines the area within which movements are possible. In our applications, map is often a bathymetry raster that defines the depth of the seabed across the study area. map is an essential field in individual movement models (see ModelMove). The internal extract() function supports the simulation of initial states (via simulate_states_init()) and the updating of states (via Patter.simulate_step()), as required to simulate animal movement paths (e.g., in simulate_path_walk() and particle_filter()). Individual states define, at a minimum, the individual's location (x, y) and the value of the map at that location (map_value), which is extracted by extract() (see State). The Coordinate Reference Systems for map, x and y must align for this to work (i.e., map should use a Universal Transverse Mercator projection with coordinates in metres). extract() is exported so that it can be used in new methods (for custom states or movement models) of these functions. The simulation of individual movements (via Patter.simulate_step()) is implemented iteratively (via Patter.simulate_move()) until a valid movement is found. NaN is taken to define inhospitable habitats, such as land, into which the individual cannot move (see is_valid()). It should be possible to use a map in another format (such as a shapefile) within these routines, with a custom extract() method that returns NaN in inhospitable habitats and a numeric constant otherwise. \n\nReturns\n\nThe value of the GeoArray for a coordinate pair within the bounds of map;\nNaN (of the same type as map's elements) for a coordinate pair beyond the bounds of map;\n\nSee also\n\nState for State sub-types;\nPatter.extract() to extract values from map at State coordinates;\nPatter.simulate_step() to simulate a new State;\nPatter.is_valid() to determine whether or not a simulated state is valid;\nPatter.simulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.is_valid","page":"Patter.jl","title":"Patter.is_valid","text":"is_valid(map_value::Real)\nis_valid(map_value::Real, z::Real)\n\n(Internal) Determine the validity of a point on a map.\n\nFor two-dimensional (x, y) states, is_valid(map_value) checks if the map_value (at a point (x, y)) is not NaN.\n\nFor states with a depth (z) component, is_valid(map_value, z), checks that map_value is not NaN and that the provided z-coordinate (z) lies within the valid range, specifically 0 < z â‰¤ map_value (i.e., the animal is not below the seabed).\n\nArguments\n\nmap_value: The value of the map in a particular location;\nz: (optional) The z-coordinate (depth) of the animal, used for states that contain a depth component only;\n\nDetails\n\nThese are internal functions. They are used to validate simulated individual states (see State). Individual states (i.e., locations) are simulated via Patter.simulate_step(). Patter.simulate_move() wraps Patter.simulate_step(), iteratively proposing states until a valid state is found. This is required to simulate animal movement paths (e.g., in simulate_path_walk() and particle_filter()).\n\nReturns\n\ntrue if the conditions for validity are met;\nfalse otherwise;\n\nSee also\n\nState for State sub-types;\nPatter.extract() to extract values from map at State coordinates;\nPatter.simulate_step() to simulate a new State;\nPatter.is_valid() to determine whether or not a simulated state is valid;\nPatter.simulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.logpdf_move-Tuple{State, State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64, Union{Nothing, Dict{<:State, Float64}}}","page":"Patter.jl","title":"Patter.logpdf_move","text":"logpdf_move(state_from::State, state_to::State, state_zdim::Bool, \n            model_move::ModelMove, \n            t::Int, \n            vmap::Union{GeoArray, Nothing}, \n            n_sim::Int,\n            cache::Union{Dict, Nothing})\n\n(Internal) Evaluate the log probability of a movement between two States (state_from and state_to). \n\nArguments\n\nstate_from: A State instance that defines a State from which the animal moved;\nstate_to: A State instance that defines a State into which the animal moved;\nstate_zdim: A Boolian that defines whether or not state_from and state_to contain a z (depth) dimension;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\nvmap: (optional) A GeoArray that maps the region within which movements from state_from are always legal. Valid regions must equal 1. vmap can be provided for 'horizontal' movement models (e.g., if state_from and state_to are StateXY instances (see State));\nn_sim: An integer that defines the number of Monte Carlo simulations (used to approximate the normalisation constant);\ncache: (optional) A Dict of normalisation constants including state_from;\n\nDetails\n\nPatter.logpdf_move() is an internal function that evaluates the log probability of a movement step between two State(s) (i.e., locations). This function wraps Patter.logpdf_step(), accounting for accounting for restrictions to movement; that is, Patter.logpdf_move() evaluates logpdf_step(state_from, state_to, model_move, t, length, heading) + log(abs(determinate)) - log(Z) where Z is the normalisation constant. If model_move is 'horizontal (e.g., state_from and state_to are two-dimensional, StateXY instances), a 'validity map' (vmap) can be provided. This is a GeoArray that define the regions within which movements between two locations are always legal. In the case of an aquatic animal, this is the region of the study area that is the sea, shrunk by state_from.mobility. In this instance, the normalisation constant is simply log(1.0). Otherwise, a Monte Carlo simulation of n_sim iterations is required to approximate the normalisation constant, accounting for invalid movements, which is more expensive (see logpdf_move_normalisation()). Set n_sim = 0 and cache = nothing for unrestricted models (i.e., if particle_filter() was implemented with n_move = 1). Patter.logpdf_move() is used for particle smoothing (see particle_smoother_two_filter()).\n\nReturns\n\nA number (log probability); \n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() and Patter.simulate_move() to simulate new States;\nPatter.logpdf_step() and Patter.logpdf_move() to evaluate the log-probability of movement between two locations;\nPatter.logpdf_move_normalisation() for estimation of the normalisation constant;\nparticle_smoother_two_filter() for the front-end function that uses these routines for particle smoothing;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.logpdf_move_normalisation-Tuple{State, Bool, ModelMove, Int64, Union{Nothing, GeoArrays.GeoArray}, Int64}","page":"Patter.jl","title":"Patter.logpdf_move_normalisation","text":"logpdf_move_normalisation(state::State, state_zdim::Bool, \n                          model_move::ModelMove, t::Int, \n                          vmap::Union{GeoArray, Nothing},\n                          n_sim::Int)\n\n(Internal) Approximate the (log) normalisation constant for the (log) probability density of movement from one State (location) into another. \n\nArguments\n\nstate: A State instance that defines a State from which the animal moved;\nstate_zdim: A Boolian that defines whether or not state contains a z (depth) dimension;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\nvmap: (optional) A GeoArray that maps the region within which movements from state are always legal. Valid regions must equal 1. vmap can be provided for 'horizontal' movement models (e.g., if state is a StateXY);\nn_sim: An integer that defines the number of Monte Carlo simulations. Set n_sim = 0 if n_move = 1 in particle_filter();\n\nDetails\n\nThis internal function computes the normalisation constant for the (log) probability of movement from one State (state) into another. If n_move = 1 in particle_filter(), set n_sim = 0 to return log(1.0). Otherwise, we need to account for the truncation of the movement model by land. If model_move is 'horizontal' (e.g., state is a two-dimensional, StateXY instance), a 'validity map' (vmap) can be provided. This is a GeoArray that define the regions within which movements from that state are always legal. In the case of an aquatic animal, this is the region of the study area that is the sea, shrunk by state.mobility. In this instance, the normalisation constant is simply log(1.0). Otherwise, a Monte Carlo simulation of n_sim iterations is used to estimate the normalisation constant. A Beta(1, 1) prior is used to correct for simulations that fail to generate valid move from state. This function is used by Patter.logpdf_move() to evaluate the (log) probability of movement between two states, which is required for particle smoothing (see particle_smoother_two_filter()).\n\nReturns\n\nA number (the log normalisation constant); \n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() and Patter.simulate_move() to simulate new States;\nPatter.logpdf_step() and Patter.logpdf_move() to evaluate the log-probability of movement between two locations;\nPatter.logpdf_move_normalisation() for estimation of the normalisation constant;\nparticle_smoother_two_filter() for the front-end function that uses these routines for particle smoothing;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.logpdf_step","page":"Patter.jl","title":"Patter.logpdf_step","text":"logpdf_step(state_from::State, state_to::State, model_move::ModelMove, length, heading)\n\n(Internal) Evaluate the (unnormalised) log probability of an (unrestricted) movement step. \n\nArguments\n\nstate_from: A State instance that defines a State from which the animal moved;\nstate_to: A State instance that defines a State into which the animal moved;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\nlength: A float that defines the step length (i.e., the Euclidean distance between state_from (x, y) and state_to (x, y));\nheading: A float that defines the angle (in polar coordinates) between state_from (x, y) and state_to (x, y);\n\nDetails\n\nPatter.logpdf_step() is an internal generic function that evaluates the (unnormalised) log probability of an (unrestricted) movement step between two State(s) (i.e., locations). Methods are provided for the built-in State and ModelMove sub-types, but need to be provided for custom sub-types. Internally, Patter.logpdf_step() is wrapped by Patter.logpdf_move(), which evaluates the log probability of movement between two States, accounting for restrictions to movement; that is, Patter.logpdf_move() evaluates logpdf_step(state_from, state_to, model_move, length, heading) + log(abs(determinate)) - log(Z) where Z is the normalisation constant. This is required for particle smoothing (see particle_smoother_two_filter()).\n\nReturns\n\nA number (log probability); \n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() and Patter.simulate_move() to simulate new States;\nPatter.logpdf_step() and Patter.logpdf_move() to evaluate the log-probability of movement between two locations;\nPatter.logpdf_move_normalisation() for estimation of the normalisation constant;\nparticle_smoother_two_filter() for the front-end function that uses these routines for particle smoothing;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.particle_filter-Tuple{}","page":"Patter.jl","title":"Patter.particle_filter","text":"particle_filter(; timeline::Vector{DateTime},\n                  xinit::Vector{<:State},\n                  yobs::Dict,\n                  model_move::ModelMove,\n                  n_move::Int = 100_000,\n                  n_record::Int = 1000,\n                  n_resample::Float64 = Float64(n_record),\n                  t_resample::Union{Nothing, Int, Vector{Int}}  = nothing,\n                  n_iter::Int64 = 1,\n                  direction::String = \"forward\", \n                  batch::Union{Nothing, Vector{String}} = nothing, \n                  progress = (), \n                  verbose::Bool = true)\n\nA particle filtering algorithm that samples from f(s_t | y_{1:t}) for t âˆˆ 1:t.\n\nArguments (keywords)\n\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\nxinit: A Vector of State instances that defines the initial state(s) of the animal;\nyobs: A Dictionary of observations:\nDictionary keys should match elements in timeline;\nEach element must be a Vector of Tuples for that time step (one for each observation/sensor);\nEach Tuple should contain (a) the observation and (b) the model parameters (that is, a ModelObs instance);\nmodel_move: A ModelMove instance:\nThe movement model describes movement from one time step to the next and therefore depends implicitly on the resolution of timeline;\nThe movement model should align with the State instances in xinit. For example, a two-dimensional state (StateXY) requires a corresponding movement model instance (i.e., ModelMoveXY);\nn_move: An integer that defines the number of attempts used to find a legal move;\nAll ModelMove sub-types contain a map field that defines the region(s) within which movements are allowed (see is_valid());\nEach particle is moved up to n_move times, until a valid movement is simulated;\nParticles that fail to generate a valid move are killed;\nn_move = 1 is permitted, which corresponds to an 'unrestricted' movement model in which particles are instantly killed if they land in inhospitable habitats on map;\nn_record: An integer that defines the number of particles to record at each time step:\nn_record particles are resampled at each time step and recorded in memory;\nn_resample: A number that defines the effective sample size for resampling:\nParticles are resampled when the effective sample size <= n_resample;\nt_resample: nothing, an integer or a Vector of integers that define the time step(s) at which to force resampling;\nParticles are resampled at t_resample regardless of the effective sample size;\nn_iter: A integer that defines the maximum number of iterations (trials);\ndirection: A String that defines the direction of the filter:\n\"forward\" runs the filter forwards in time;\n\"backward\" runs the filter backwards in time;\n(optional) batch: A Vector of .jld2 file paths for particles (see Memory Management);\n(optional) progress: A NamedTuple of arguments, passed to ProgressMeter.Progress, to control the progress bar. If enabled, one progress bar is shown for each batch;\nverbose: A Bool that defines whether or not to print information to the console;\n\nAlgorithm\n\nInitiation\n\nThe algorithm is initiated using a Vector of n_particle States (xinit). See simulate_states_init() to simulate initial states for the filter.\n\nMovement\n\nFor every time step in the timeline, the internal function Patter.simulate_move() simulates the movement of particles away from previous States into new States using the movement model, as specified by model_move. Patter.simulate_move() is an iterative wrapper for a Patter.simulate_step() method that simulates a new State instance from the previous State. Patter.simulate_move() implements Patter.simulate_step() iteratively until a legal move is found (or n_move is reached). For custom State or ModelObs sub-types, a corresponding Patter.simulate_step() method is required. Illegal moves are those that land in NaN locations on the map or, in the case of States that include a depth (z) component, are below the depth of the seabed (see is_valid()). Particles that fail to generate legal moves are eventually killed by re-sampling (see below).\n\nLikelihood\n\nObservations are used to weight simulated particles. To simulate observations for filtering, use simulate_yobs(). To assemble real-world observations for filtering, see assemble_yobs(). For each valid State and time stamp in yobs, the log-probability of each observation, given the State, is evaluated via Patter.logpdf_obs(). For custom State or ModelObs sub-types, a corresponding Patter.logpdf_obs() method is required. The maximum weight across all particles (maxlp) is recorded at each time step as an algorithm diagnostic. (This metric can be intepreted as the maximum log-posterior if resampling is implemented at every time step.)\n\nResampling\n\nParticles are periodically re-sampled, with replacement, using the low-variance systematic re-sampling algorithm (via Patter.resample()), at time steps in t_resample or when the effective sample size is less than or equal to n_resample. This has the effect of eliminating impossible particles and duplicating likely ones.\n\nThe algorithm continues in this way, iterating over the timeline, simulating, weighting and (re)sampling particles. At each time step, n_record particles are saved in memory. If the function fails to converge, a warning is returned alongside the outputs up to that time step. Otherwise, the function will continue to the end of the time series.\n\nMulti-threading\n\nThe iteration over particles (i.e., simulated movements and likelihood evaluations) are multi-threaded.\n\nMemory management\n\nBy default, n_record particles at each time step are retained in memory. If batch is provided, the timeline is split into length(batch) batches. The filter still moves along the whole timeline, but only records the particles for the current batch in memory. At the end of each batch, the particles for that batch are written to file. This reduces total memory demand. \n\nbatch file paths are sorted alphanumerically if direction = \"forward\" and in reverse order if direction = \"backward\". For example: \n\nIf you have a timeline of 10 time steps, direction = \"forward\" and batch = [\"fwd-1.jld2\", \"fwd-2.jld2\", \"fwd-3.jld2\"], fwd-1.jld2, fwd-2.jld2 and fwd-3.jld2 contain the particle matrices for time steps [1, 2, 3], [4, 5, 6] and [7, 8, 9, 10], respectively. \nIf you have a timeline of 10 time steps, direction = \"backward\" and batch = [\"bwd-1.jld2\", \"bwd-2.jld2\", \"bwd-3.jld2\"], bwd-1.jld2, bwd-2.jld2 and bwd-3.jld2 similarly contain the particle matrices for time steps [1, 2, 3], [4, 5, 6] and [7, 8, 9, 10], respectively. \n\nConvergence and diagnostics\n\nAlgorithm convergence is not guaranteed. The algorithm may reach a dead-endâ€“-a time step at which there are no valid locations into which the algorithm can step. This may be due to data errors, incorrect assumptions, insufficient sampling effort or poor tuning-parameter settings.\n\nReturns\n\nA Particles structure;\n\nSee also\n\nState, ModelMove and ModelObs for State, movement model and observation model sub-types;\nsimulate_yobs() and assemble_yobs() to prepare observations for the particle filter;\nPatter.simulate_step() and Patter.simulate_move() for the internal routines used to simulate new States;\nPatter.logpdf_obs() methods to evaluate the log probability of observations;\nparticle_smoother_two_filter() to implement particle smoothing;\n\n\n\n\n\n","category":"method"},{"location":"#Patter.particle_smoother_two_filter-Tuple{}","page":"Patter.jl","title":"Patter.particle_smoother_two_filter","text":"particle_smoother_two_filter(; timeline::Vector{DateTime}, \n                               xfwd::Union{Matrix{<:State}, Vector{String}}, \n                               xbwd::Union{Matrix{<:State}, Vector{String}}, \n                               model_move::ModelMove, \n                               vmap::Union{GeoArray, Nothing} = nothing, \n                               n_sim::Int = 100, \n                               n_particle::Union{Nothing, Int} = nothing,\n                               cache::Bool = true, \n                               batch::Union{Nothing, Vector{String}} = nothing, \n                               progress = true, \n                               verbose::Bool = true)\n\nA two-filter particle smoother that samples from f(s_t | y_{1:T}) for t âˆˆ 1:T.\n\nArguments (keywords)\n\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\nxfwd, xbwd: Particles from the forward and backward filters (see particle_filter()), supplied as:\nA Matrix of States (in memory);\nA Vector of file paths, if particle_filter() was implemented with batch;\nmodel_move: A ModelMove instance;\nvmap: (optional) A GeoArray that defines the 'validity map' (see Patter.logpdf_move());\nn_sim: An integer that defines the number of Monte Carlo simulations (see Patter.logpdf_move());\n(optional) n_particle: An integer that defines the number of particles for smoothing. If nothing, all particles are used;\ncache: A Bool that defines whether or not to precompute and cache movement density normalisation constants (see Patter.logpdf_move());\n(optional) batch: A Vector of .jld2 file paths for particles (see particle_filter());\n(optional) progress: A NamedTuple of arguments, passed to ProgressMeter.Progress, to control the progress bar. If enabled, one progress bar is shown for each batch;\nverbose: A Bool that defines whether or not to print information to the console;\n\nDetails\n\nparticle_smoother_two_filter() smooths particles from the particle filter (see particle_filter()). The timeline from the particle filter should be supplied as well as a Matrix of particles from a forward run and a backward run (or a Vector of file paths to those matrices). The two filter smoother works by iteratively resampling particles in line with the probability density of movement between particles from the backward filter at time t and particles from the forward filter at time t - 1. Patter.logpdf_move() is an internal function that evaluates the log probability of a movement step between particles. This function wraps the Patter.logpdf_step() generic. Methods are provided for built-in State and ModelMove sub-types. To use custom sub-types, a corresponding Patter.logpdf_step() method should be provided. In particle_smoother_two_filter(), the vmap and n_sim arguments support the calculate of probability densities (see Patter.logpdf_move()). For movement models for which the density only depends on fields in xbwd and xfwd, set cache = true to precompute and store normalisation constants for density calculations for unique xbwd elements. Note that since typically only a subsample of particles from particle_filter() are retained in memory, it is not guaranteed that valid moves will exist between particle pairs at all time steps. At time step(s) in which the two filters are incompatible, 50 % of particles are retained from the forward filter and 50 % from the backward filter with a warning. The effective sample size at such time steps is set to NaN, providing an index and counter for problematic time steps (see Returns). Batching is only implemented if the inputs (xfwd, and xbwd) and outputs (via batch) are batched (and contain the same number of batches). \n\nReturns\n\nA Particles structure;\n\nSee also\n\nparticle_filter() implements the particle filter;\nPatter.logpdf_step(), logpdf_move_normalisation() and Patter.logpdf_move() evaluate the log probability (density) of movement between two States;\nparticle_smoother_two_filter() implements the two-filter particle smoother;\n\nSource\n\nFearnhead, P., Wyncoll, D., Tawn, J., 2010. A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447â€“464.\n\n\n\n\n\n","category":"method"},{"location":"#Patter.resample","page":"Patter.jl","title":"Patter.resample","text":"resample(w::Vector{Float64}, n::Int)\n\n(Internal) Given a weight vector w, resample a set of indices based on low-variance resampling algorithm from Thrun, Burgard and Fox's \"Probabilistic Robotics\".\n\nArguments\n\nw: A Vector{Float64} of weights;\nn: An integer that defines the number of particles;\n\nDetails\n\nThis is an internal function that implements systematic resampling in the particle filter (see particle_filter()) and smoothing algorithms (see particle_smoother_two_filter()). Note that for large n, the function is not numerically stable.\n\nReturns\n\nAn integer vector of indices;\n\nExample\n\nX = [\"A\", \"B\", \"C\", \"D\"]\nw = [0, 0, 0.75, 0.25]\n\nidx = resample(w, 12)\nX[idx]\n\nSource\n\nCode adapted from https://github.com/JuliaStats/StatsBase.jl/issues/124.\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_move","page":"Patter.jl","title":"Patter.simulate_move","text":"simulate_move(state::State, model_move::ModelMove, t::Int64, n_trial::Real)\n\n(Internal) Simulate movement from one location (State) into a new location (State).\n\nArguments\n\nstate: A State instance that defines the animal's previous State;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\nn_trial: A number that defines the number of attempts to simulate a valid State;\n\nDetails\n\nPatter.simulate_move() is an internal function that uses a Patter.simulate_step() method to simulate new state proposals iteratively until a valid State is generated or n_trial is reached (see is_valid()). For custom States or ModelMove sub-types, corresponding Patter.simulate_step() methods must be provided for this function. Patter.simulate_move() is used to simulate movement paths (e.g., in simulate_path_walk() and particle_filter()).\n\nReturns\n\nA Tuple that comprises the simulated State instance and the (log) weight; i.e., \n([State], 0.0) if State is valid;\n([State], -Inf) if State is invalid;\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() to simulate a new State;\nPatter.is_valid() to determine whether or not a simulated state is valid;\nPatter.simulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_path_walk-Tuple{}","page":"Patter.jl","title":"Patter.simulate_path_walk","text":"simulate_path_walk(; xinit = Vector, model_move::ModelMove, timeline::Vector{DateTime})\n\nSimulate discrete-time movement path(s) from a Vector of initial States and a random-walk movement model. \n\nArguments (keywords)\n\nxinit: A Vector of initial States instances;\nmodel_move: A ModelMove instance;\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\n\nDetails\n\nState refers to the (x, y) location of an animal (alongside additional state components, if applicable). To simulate initial states, use simulate_states_init(). For each initial state, simulate_path_walk() simulates a sequence of States (i.e., a movement path) of length(timeline) steps using the movement model (model_move). The simulation of movement from one State into another is implemented by the internal function Patter.simulate_move(), which in turn wraps Patter.simulate_step(). At each time step, Patter.simulate_move() implements Patter.simulate_step() iteratively until a valid movement is identified (see is_valid()). Patter.simulate_step() is a generic function. Methods are implemented for the built-in State and ModelMove sub-types but custom sub-types require a corresponding Patter.simulate_step() method. \n\nReturns\n\nA matrix of States:\nEach row represents a simulated path;\nEach column represents a time step along timeline;\n\nSee also\n\n\n\n\n\n","category":"method"},{"location":"#Patter.simulate_states_init","page":"Patter.jl","title":"Patter.simulate_states_init","text":"simulate_states_init(; map::Rasters.Raster,\n                       timeline::Vector{DateTime}, \n                       state_type::Type{<: State}, \n                       xinit::Union{Nothing, DataFrame}, \n                       model_move::ModelMove, \n                       datasets::Union{Nothing, Vector}, \n                       model_obs_types::Union{Nothing, Vector}, \n                       n_particle::Int, \n                       direction::String = \"forward\", \n                       output = \"DataFrame\")\n\nSimulate a DataFrame or Vector of initial States for the simulation of movement paths in simulate_path_walk() and particle_filter().\n\nArguments\n\nmap: A Rasters.Raster that defines the study area for the simulation. Here, map is used to:\nSample initial coordinates, via Patter.coords_init(), if xinit = nothing;\ntimeline, model_move, datasets, model_obs_types, direction: Additional arguments used to restrict map, via Patter.map_init(), before sampling initial states.\ntimeline: A sorted, DateTime vector of regularly spaced time stamps that defines the timeline for the simulation;\nmodel_move: A ModelMove instance;\n(optional) datasets: A Vector of observation datasets or nothing;\n(optional) model_obs_types: A Vector of ModelObs sub-types or nothing;\ndirection: A String string that defines the direction of the simulation (\"forward\" or \"backward\");\nstate_type: The State sub-type. Here, state is used to:\nConvert sampled coordinates to initial states, via Patter.states_init(), if xinit = nothing;\nxinit: (optional) A DataFrame of initial states, with one column for each state dimension.\nn_particle: An integer that defines the number of simulated states:\nIf xinit = nothing, n_particle specifies the number of simulated states via Patter.coords_init();\nIf xinit is supplied but there are not n_particle initial states, n_particle initial states are re-sampled from xinit with replacement;\noutput: A String that defines the output format:\n\"DataFrame\" returns a DataFrame (for communication with R);\n\"Vector\" returns a Vector of `State(s);\n\nDetails\n\nThese functions support the simulation of initial states for animal movement walks in simulate_path_walk() and particle_filter().\n\nIf xinit = nothing, initial coordinates are sampled from map.\n\nThe region(s) within map from which initial coordinates are sampled can be optionally restricted by the provision of the observation datasets and the associated model sub-types (via Patter.map_init_iter()). This option does not apply to simulate_path_walk() but is used in particle_filter() where observation models are used. In this instance, Patter.map_init_iter() iterates over each model and uses the Patter.map_init() method to update map. The following methods are implemented:\n\nDefault. The default method returns map unchanged.\nmodel_obs_type::ModelObsAcousticLogisTrunc. This method uses acoustic observations to restrict map via Lavender et al.'s (2023) acousticâ€“container algorithm. The function identifies the receiver(s) that recorded detection(s) immediately before, at and following the first time step (timeline[start], where start is 1 if direction = \"forward\" and length(timeline) otherwise). The 'container' within which the individual must be located from the perspective of each receiver is defined by the time difference and the individual's mobility (that is, the maximum moveable distance the individual could move between two time steps), which must be specified in model_move.mobility. The intersection between all containers defines the possible locations of the individual at the first time step.\nmodel_obs_type::ModelObsDepthUniformSeabed. This method uses the depth observations to restrict map (which should represent the bathymetry in a region). The individual must be within a region in which the observed depth at timeline[start] is within a depth envelope around the bathymetric depth defined by the parameters depth_shallow_eps and depth_deep_eps (see ModelObs). (If there is no observation at timeline[start], map is returned unchanged.)\nmodel_obs_type::ModelObsDepthNormalTruncSeabed. This method also uses depth observations to restrict map. The individual must be in a location where the bathymetric depth plus the depth_deep_eps parameter at timeline[start] is greater than or equal to the observed depth at timeline[start] (see ModelObs). (If there is no observation at timeline[start], map is returned unchanged.)\n\nTo handle custom ModelObs sub-types, process map beforehand or write an appropriate Patter.map_init() method.\n\nUsing map, a DataFrame of n_particle initial coordinates (map_value, x, y) is sampled using Patter.coords_init(). Additional state dimensions are added, as required depending on the state_type, via a Patter.states_init() method. For custom State sub-types, a corresponding Patter.states_init() method is required (or supply xinit yourself).\n\nIf xinit() is provided and n_particle initial states are provided, xinit is returned unchanged. Otherwise, n_particle initial states are resampled from xinit, with replacement, and returned.\n\nReturns\n\nsimulate_states_init() returns:\n\nIf output = \"DataFrame\", a DataFrame, with n_particle rows, and one column for each State dimension;\nIf output = \"Vector\", a Vector of State instances, with n_particle elements;\n\nSee also\n\nThese functions are used to initialise simulated movement trajectories in simulate_path_walk() and particle_filter(). See also:\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() and Patter.simulate_move() to simulate new States;\nsimulate_path_walk() to simulate animal movement paths (via ModelMove);\nsimulate_yobs() to simulate observations arising from simulated movements (via ModelObs);\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_step","page":"Patter.jl","title":"Patter.simulate_step","text":"simulate_step(state::State, model_move::ModelMove, t::Int64)\n\n(Internal) Simulate a (tentative) step from one location (State) into a new location (State).\n\nArguments\n\nstate: A State instance that defines the animal's previous State;\nmodel_move: A ModelMove instance;\nt: An integer that defines the time step;\n\nDetails\n\nPatter.simulate_step() is an internal generic function that simulates a new value for the animal's [State], that is, the animal's location (and other state components). Methods are provided for the built-in [State] and movement model (ModelMove) sub-types. For custom States or ModelMove sub-types, corresponding methods must be provided. Internally, Patter.simulate_step() is wrapped by Patter.simulate_move(), which implements simulate_step() iteratively until a valid State is simulated (see is_valid()). \n\nReturns\n\nA State instance;\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() to simulate a new State;\nPatter.is_valid() to determine whether or not a simulated state is valid;\nPatter.simulate_move() to simulate states iteratively until a valid state is found;\nsimulate_path_walk() and particle_filter() for the front-end functions that use these routines to simulate animal movement paths;\n\n\n\n\n\n","category":"function"},{"location":"#Patter.simulate_yobs-Tuple{}","page":"Patter.jl","title":"Patter.simulate_yobs","text":"simulate_yobs(; paths::Matrix{<:State}, model_obs::Vector{ModelObs}, timeline::Vector{DateTime})\n\nFor a series of simulated paths, simulate a dictionary of observations. \n\nArguments\n\npaths: A Matrix of simulated paths from simulate_path_walk();\nmodel_obs: A Vector of ModelObs instances;\ntimeline: A Vector{DateTime} of ordered, regularly spaced time stamps that defines the time steps for the simulation;\n\nDetails\n\nThe function expects a Matrix of simulated paths (see simulate_path_walk()). For each simulated path, the function iterates over each step in timeline and simulates observations using the Vector of observation models. Observations are simulated by the internal generic Patter.simulate_obs() via simulate_obs(State, model, t), where t is the time step. Methods are provided for the built-in States and ModelObs sub-types. For custom sub-types, a corresponding Patter.simulate_obs() method is required. Simulated observations can be used in the particle filter to reconstruct the underlying movements (see particle_filter()).\n\nReturns\n\nA Dict, with one entry for each path:\nEach entry is a Dict, with one entry for each time stamp;\nEach time stamp entry is a Vector of Tuples, each comprising the simulated observation and the associated ModelObs instance (see also assemble_yobs());\n\nSee also\n\nState and ModelMove for State and movement model sub-types;\nPatter.simulate_step() and Patter.simulate_move() to simulate new States;\nsimulate_path_walk() to simulate animal movement paths (via ModelMove);\nsimulate_yobs() to simulate observations arising from simulated movements (via ModelObs);\n\n\n\n\n\n","category":"method"},{"location":"#Patter.ModelMove","page":"Patter.jl","title":"Patter.ModelMove","text":"Movement models\n\nModelMove is an Abstract Type that groups movement models. \n\nBuilt-in sub-types\n\nModelMove sub-types define the components of different kinds of movement model. The following sub-types are built-in:\n\nRandom walks (RWs):       - ModelMoveXY(map, mobility, dbn_length, dbn_heading): A sub-type for two-dimensional (x, y) random walks, based distributions for step lengths (dbn_length) and headings (dbn_heading);       -  ModelMoveXYZ(map, mobility, dbn_length, dbn_heading, dbn_z): A subtype for a RW in X, Y and Z, based on distributions for step lengths (dbn_length), headings (dbn_heading) and depth (dbn_z);\nCorrelated random walks (CRWs):       -   ModelMoveCXY(map, mobility, dbn_length, dbn_heading_delta): A sub-type for a CRW in X and Y, based on distributions for step lengths (dbn_length) and turning angles (dbn_heading_delta) ;       -   ModelMoveCXYZ(map, mobility, dbn_length, dbn_heading_delta, dbn_z_delta): A sub-type for a CRW in X, Y and Z, based on distributions for step lengths (dbn_length), turning angles (dbn_heading_delta) and changes in depth (dbn_z_delta);\n\nThese contain the following fields: \n\nmap: A field that defines the arena within which movement occurs. The coordinate reference system of the map must align with the other components of the movement model, which typically require a Universal Transverse Mercator (planar) projection with coordinates in metres. map is required by all movement models;\nmobility: A number that defines the maximum movement distance between two time steps;\ndbn_length: The distribution of step lengths;\ndbn_heading: The distribution of headings;\ndbn_heading_delta: The distribution of turning angles;\ndbn_z: The distribution of depths;\ndbn_z_delta: The distribution of changes in depth;\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelMoveXYZ*, simply define a struct that is a sub-type of Patter.ModelMove:\n\nstruct ModelMoveXYZ{T, U, V, W, X} <: Patter.ModelMove\n    # The environment (i.e., map)\n    # > This defines the regions within which movements are permitted (i.e., in water)\n    map::T\n    # Distribution for step lengths\n    mobility::U\n    dbn_length::V\n    # Distribution for headings\n    dbn_heading::W\n    # Distribution for changes in depth\n    dbn_z::X\n  end\n\nNote this structure is now implemented. \n\nNew ModelMove structures should obey the following requirements:\n\nThe map and mobility fields are required by all ModelMove sub-types; \nBy default, map is assumed to be a GeoArray but a shapefile can be used with a custom extract() method;\n\nTo use a new ModelMove sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding State sub-type;\n(optional) Define Patter.map_init() and Patter.states_init() methods for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in particle_smoother_two_filter());\n\n\n\n\n\n","category":"type"},{"location":"#Patter.ModelObs","page":"Patter.jl","title":"Patter.ModelObs","text":"Observation models\n\nModelObs\n\nModelObs is an Abstract Type that groups observation model structures. See below for built-in sub-types. \n\nBuilt-in sub-types\n\nModelObsAcousticLogisTrunc\n\nModelObsAcousticLogisTrunc is a ModelObs structure for an acoustic observation (0, 1) and a truncated logistic detection probability model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (receiver) ID;\nreceiver_x, receiver_y: Floats that define the x and y coordinates of the receiver;\nreceiver_alpha, receiver_beta, receiver_gamma: Floats that define the parameters of a truncated logistic detection probability model. \n\nAn acoustic observation (y^(A)_t k in 0 1) at receiver k (location textittextbfr_k = (textreceiver_x textreceiver_y)) at time t is modelled using a Bernoulli probability mass function:\n\nf(y^(A)_t k  textittextbfs_t) = textBernoulli(p_kt(textittextbfs_t))\n\nwhere p_kt(textittextbfs_t) is the probability of a detection at receiver k at time t given a transmission from location textittextbfs_t = (x y). ModelObsAcousticLogisTrunc represents p_kt(textittextbfs_t) as a logistic function of the Euclidean location between the receiver and the transmitter, according to the equation:\n\np_kt(textittextbfs_t) = left\nbeginarrayll\n(1 + e^-(textreceiver_alpha - textreceiver_beta cdot textittextbfs_t - textittextbfr_k))^-1  textif  textittextbfs_t - textittextbfr_k  textreceiver_gamma \n0  textotherwise\nendarray\nright\n\nwhere textreceiver_gamma is the detection range. \n\nTo simulate an acoustic observation (y^(A)_t k in 0 1) from this model, we can draw a sample from a Bernoulli distribution:\n\ny^(A)_t k  textittextbfs_t sim textBernoulli(p_kt(textittextbfs_t))\n\nvia Patter.simulate_obs().\n\nModelObsDepthUniformSeabed\n\nModelObsDepthUniformSeabed is ModelObs structure for a depth observation and a uniform depth model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_shallow_eps: A float that defines the shallow depth error;\ndepth_deep_eps: A float that defines the deep depth error;\n\nThis model assumes that an individual must be located in an envelope around the seabed, defined by two error terms (depth_shallow_eps and depth_deep_eps), according to the equation:\n\nfleft( y_t^(D)   textittextbfs_t right) =\nbegincases \nz_t  textif  b(textittextbfs_t) - textdepth_shallow_eps leq y_t^(D) leq b(textittextbfs_t) + textdepth_deep_eps \n0  textotherwise\nendcases\n\nwhere y_t^(D) is the observed depth, b(textittextbfs_t) is the bathymetric depth in location textittextbfs_t and z_t is a constant. If depth_shallow_eps and depth_deep_eps are zero, the individual's depth is required to match the bathymetric depth.\n\nWe can simulate observations from this model as follows:\n\ny_t^(D)   textittextbfs_t sim textUniform(b(textittextbfs_t) + textdepth_deep_eps textmin(b(textittextbfs_t) - textdepth_shallow_eps 0))\n\nvia Patter.simulate_obs(). If depth_shallow_eps and depth_deep_eps are set to zero, the Patter.simulate_obs() method simply returns the bathymetric depth (state.map_value).\n\nModelObsDepthNormalTruncSeabed\n\nModelObsDepthNormalTruncSeabed is a ModelObs structure for a depth observation and a truncated normal model. This contains the following fields:\n\nsensor_id: An integer that defines the sensor (tag) ID;\ndepth_sigma: A float that defines the standard deviation of the normal distribution;\ndepth_deep_eps: A float that defines the deep truncation parameter;\n\nThis model assumes that an individual must be located in an envelope around the seabed, defined by a normal distribution centred at this location with standard deviation depth_sigma: \n\nf(y_t^(D)  textittextbfs_t) = textTruncatedNormal(b(textittextbfs_t) textdepth_sigma^2 0 b(textittextbfs_t))\n\nWe can simulate observations from this model as for previous models via Patter.simulate_obs().\n\nModelObsContainer\n\nModelObsContainer is a ModelObs structure for a container. Containers are a computational device used to mitigate particle degeneracy in the particle filter. Containers define the maximum possible distance of an individual from a location (e.g., receiver) that recorded a future observation. Accordingly, the ModelObsContainer structure contains the following fields:\n\nsensor_id: An integer that defines the sensor ID (e.g., the receiver ID for the receiver that recorded the next detection);\ncentroid_x, centroid_y: Floats that define the x and y coordinates of the container's centroid;\nradius: A Float that defines the radius of the container; \n\nAn acoustic container defines the region within which an individual must be located according to the receiver(s) at which it was next detected. In the particle filter, particles are permitted or killed depending on whether or not they are compatible with this constraint.\n\nWe formalise the acoustic container constraint as follows. Let t denote the movement timeline (where t in 12 dots T), boldsymbols denote the individual's latent state (typically (x,y) location), boldsymboly denote acoustic observations (detections, non-detections) at receivers and boldsymboltheta denote static parameters (in the movement and observation models). The likelihood of the observations boldsymboly_1T given the parameters boldsymboltheta is expressed as\n\nf(boldsymboly_1Tmidboldsymboltheta) =\nint\nprod_t=1^T\nf(boldsymboly_tmidboldsymbols_tboldsymboltheta)\n f(boldsymbols_tmidboldsymbols_t-1boldsymboltheta)\n dboldsymbols_1T\n\nAcoustic containerisation represents a redefinition of the likelihood f(boldsymboly_tmidboldsymbols_tboldsymboltheta), in a manner that does not affect the likelihood f(boldsymboly_1Tmidboldsymboltheta), with the addition of a characteristic function chi(tboldsymbols_tboldsymboly) in 01 that returns zero or one depending on whether or not the latent state boldsymbols_t is compatible with the observations at some future time:\n\nf(boldsymboly_1Tmidboldsymboltheta) =\nint\nprod_t=1^T\nf(boldsymboly_tmidboldsymbols_tboldsymboltheta)\n chi(tboldsymbols_tboldsymboly)\n f(boldsymbols_tmidboldsymbols_t-1boldsymboltheta)\n dboldsymbols_1T\n\nThe characteristic function chi(tboldsymbols_tboldsymboly) is defined as follows.   Let Delta(t) be a function that identifies the next time step (at some time after t) at which detection(s) were recorded.   At time t the individual must be within a maximum distance (denoted textradius_k) of each receiver k that recorded the next detection(s):\n\nchi(tboldsymbols_tboldsymboly) =\nprod_k\nchi_kbigl(\nlVert boldsymbolr_kDelta(t) - boldsymbols_t rVert\nle textradius_k(textmobility)\nbigr)\n\nwhere boldsymbolr_kDelta(t) denotes the location of receiver k.\n\nThe radius for receiver k at time t depends on the number of time steps from t until the detection event (Delta(t)-t), a parameter textmobility in boldsymboltheta that defines the maximum possible moveable distance in between two time steps (i.e., from t to t+1) and the receiverâ€™s maximum detection range gamma in boldsymboltheta:\n\ntextradius(textmobility) =\n(Delta(t)-t)textmobility + gamma\n\nIn practice, acoustic containers are implemented via the ModelObsContainer structure (that is, we treat the container like an additional observation, even though it is simply a redundant use of the data).  ModelObsContainer instances must be assembled before the filter run, following the equations above. For relevant time steps, it is necessary to build a ModelObsContainer for each of the receiver(s) that recorded a detection at the next detection time step. Each instance contains centroid_x and centroid_y elements that define the centroid of the container and a radius element that defines the maximum possible distance of the individual from the container centroid (see above).\n\nIn the particle filter, at each time t, we iterate over all observationâ€‘model structures and update particle weights using a Patter.logpdf_obs method. For ModelObsContainer instances, the Patter.logpdf_obs method computes the distance between the particle (i) and receiver kâ€™s location (centroid) and adds 00 or text-Inf to the log weight (textlw) depending on whether or not the distance is less than the radius:\n\ntextlw_i =\ntextlw_i +\nlogbigl(\nchi_kbigl(\nlVert boldsymbolr_kDelta(t) - boldsymbols_t rVert\nle textradius_k(textmobility)\nbigr)\nbigr)\n\nThis approach is valid because we only kill particles that are incompatible with future observations. A filteringâ€“smoothing algorithm that implements acoustic containerisation thus still approximates f(boldsymbols_tmidboldsymboly_1T) once all data have been taken into account.\n\nCustom sub-types\n\nTo define a custom sub-type, such as ModelObsDepthNormal, simply define a struct that is a sub-type of Patter.ModelObs:\n\nstruct ModelObsDepthNormal <: Patter.ModelObs\n    sensor_id::Int64\n    depth_sigma::Float64\nend\n\nFor communication with R, all sub-types should include a sensor_id field. \n\nAdd corresponding methods to simulate observations via Patter.simulate_obs() and to evaluate log probabilities via Patter.logpdf_obs(). \n\nSimulation\n\nPatter.simulate_obs() is an internal generic function that simulates observations, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.simulate_obs(state::StateCXYZ, model_obs::ModelObsDepthNormal, t::Int64)\n    dbn   = truncated(Normal(state.z, model_obs.depth_sigma), 0, state.map_value)\n    rand(dbn)\nend\n\nPatter.simulate_obs() is wrapped by simulate_yobs() for the simulation of observations.\n\nLog probabilities\n\nPatter.logpdf_obs() is a generic function that calculates the log probability (density) of an observation, given the animal's State and a ModelObs instance. This accepts the following arguments:\n\nstate: A State instance;\nmodel_obs: A ModelObs instance;\nt: An integer that defines the time step;\nobs: The observation;\n\nMethods are implemented for all built-in sub-types. Methods can be defined for new sub-types, such as ModelObsDepthNormal, as follows:\n\nfunction Patter.logpdf_obs(state::State, model_obs::ModelObsDepthNormal, t::Int64, obs::Float64)\n    dbn   = truncated(Normal(state.map_value, model_obs.depth_sigma),\n                      0.0, state.map_value)\n    logpdf(dbn, obs)\n  end\n\nPatter.logpdf_obs() is used in particle_filter() to evaluate the log-probability of the data given particle samples.\n\n\n\n\n\n","category":"type"},{"location":"#Patter.Particles","page":"Patter.jl","title":"Patter.Particles","text":"Particles(states::Union{Nothing, Matrix{<:State}}, diagnostics::DataFrame, callstats::DataFrame)\n\nFields\n\nstates: (optional) A Matrix of States:\nEach row corresponds to a particle;\nEach column corresponds to the timestep;\ndiagnostics: A DataFrame of algorithm diagnostics:\ntimestep: A Vector{Int64} of time steps;\ntimestamp: A Vector{DateTime} of time stamps;\ness: A Vector{Float64} that defines the effective sample size at each time step;\nmaxlp:  Vector{Float64} that defines the maximum log weight at each time step (i.e., the maximum log-posterior, if resampling is implemented at every time step);\ncallstats: A one-row DataFrame of call statistics:\ntimestamp: A DateTime that define the start time of the function call;\nroutine: A String that defines the algorithm;\nn_particle: An Int that defines the number of particles;\nn_iter: An Int or NaN that defines the number of iterations (trials);\nconvergence: A Boolian that defines convergence;\nloglik: A Float64 that defines the log-likelihood (log P(observations | Î¸));\ntime: A Float64 that defines the duration (s) of the function call;\n\nDetails\n\nstates is nothing if particle_filter() or particle_smoother_two_filter() are implemented with batching. \nconvergence is defined as follows:\nIn particle_filter(), convergence defines whether or not the filter reached the end of the timeline;\nIn particle_smoother_two_filter(), convergence defines whether or not correct smoothing was achieved on at least 95 % of time steps. 'Correct smoothing' is possible when there at at least some valid moves between the subset of recorded particles on the backward filter and those on the forward filter (for the previous time step). \n\nSee also\n\nParticles objects are returned by:\n\nparticle_filter()\nparticle_smoother_two_filter()\n\n\n\n\n\n","category":"type"},{"location":"#Patter.State","page":"Patter.jl","title":"Patter.State","text":"State\n\nState is an Abstract Type that defines the animal's state at a given time step. \n\nBuilt-in sub-types\n\nThe following sub-types are built-in:\n\nStateXY(map_value, x, y): Used for two dimensional (x, y) states;\nStateXYZ(map_value, x, y, z): Used for three-dimensional (x, y, z) states;\nStateCXY(map_value, x, y, heading): Used for two-dimensional (x, y) correlated states;\nStateCXYZ(map_value, x, y, z, heading): Used for three-dimensional (x, y, z) correlated states;\n\nThese contain the following fields: \n\nmap_value: The value of the movement map at coordinates (x, y), required for all States (see ModelMove);\nx, y:  Floats that define the animal's x and y coordinates, required for all States;\nz: A float that defines the animal's z (depth) coordinate, required for all States with a depth component;\nheading: A float that defines the heading, required by StateCXYZ;\n\nCustom sub-types\n\nTo define a custom sub-type, such as StateXYZ*, simply define a struct that is a sub-type of Patter.State:\n\nstruct StateXYZ <: Patter.State\n    # Map value\n    map_value::Float64\n    # Coordinates\n    x::Float64\n    y::Float64\n    z::Float64\nend\n\nNote that StateXYZ is now implemented.\n\nNew states should obey the following requirements:\n\nAll states must include map_value, x and y fields;\nFor states with a depth dimension, the depth field must be named z (for Patter.simulate_move());\nFor R users, all fields must be of type Float64 for Patter.r_get_states() to parse state vectors;\n\nTo use a new State sub-type in the simulation of animal movements (via simulate_path_walk()) and particle-filtering algorithms, the following steps are also necessary:\n\nDefine a corresponding ModelMove sub-type;\n(optional) Define Patter.map_init() and Patter.states_init() methods for simulate_states_init() to simulate initial states;\nDefine a Patter.simulate_step() method (for Patter.simulate_move()) to update the state using a ModelMove instance (in simulate_path_walk() and particle_filter());\nDefine a Patter.logpdf_step() method (for Patter.logpdf_move()) to evaluate the probability density of movement from one state to another (in particle_smoother_two_filter());\n\n\n\n\n\n","category":"type"},{"location":"#Index","page":"Patter.jl","title":"Index","text":"","category":"section"},{"location":"","page":"Patter.jl","title":"Patter.jl","text":"","category":"page"}]
}
